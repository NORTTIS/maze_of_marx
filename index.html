<!DOCTYPE html>
<html lang="vi">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>MLN122 - Maze of Marx</title>
        <style>
            /* CSS Styling */
            html,
            body {
                height: 100%;
            }
            body {
                margin: 0;
                background: #0b0c12;
                color: #e5e7eb;
                font-family: ui-monospace, Consolas, monospace;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }
            header {
                background: #0f1324;
                border-bottom: 2px solid #1e2a4b;
                padding: 10px 12px;
                position: sticky;
                top: 0;
                z-index: 3;
            }
            h1 {
                font-size: 16px;
                margin: 0;
                color: #5ff9d1; /* M√†u xanh ng·ªçc */
            }
            .hud {
                display: flex;
                gap: 12px;
                flex-wrap: wrap;
                margin-top: 6px;
                font-size: 14px;
            }
            .pill {
                padding: 4px 10px;
                border: 1px solid #1e2a4b;
                border-radius: 8px;
                background: #1e2a4b;
                display: flex;
                align-items: center;
                gap: 6px;
            }
            .pill span {
                font-weight: bold;
                color: #fca311; /* M√†u cam */
            }
            main {
                flex-grow: 1;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 20px;
                position: relative;
            }
            canvas {
                border: 4px solid #1e2a4b;
                border-radius: 12px;
                background: #1e2a4b;
                box-shadow: 0 0 20px rgba(0, 255, 200, 0.1);
            }
            dialog {
                border: none;
                border-radius: 10px;
                padding: 20px;
                background: #1a1a2e;
                color: #e5e7eb;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                max-width: 90vw;
                width: 400px;
            }
            dialog::backdrop {
                background: rgba(0, 0, 0, 0.7);
                backdrop-filter: blur(5px);
            }
            .modal-content h2 {
                margin-top: 0;
                color: #5ff9d1;
            }
            .options-box button {
                display: block;
                width: 100%;
                padding: 12px;
                margin-top: 10px;
                border: none;
                border-radius: 8px;
                background: #ff5722;
                color: white;
                font-size: 16px;
                cursor: pointer;
                transition: background 0.2s, transform 0.1s;
                font-weight: bold;
            }
            .options-box button:hover {
                background: #e64a19;
            }
            .options-box button:active {
                transform: scale(0.98);
            }
            .dice-display {
                font-size: 48px;
                text-align: center;
                margin: 20px 0;
                animation: roll 0.5s ease-in-out;
            }
            @keyframes roll {
                0% {
                    transform: rotateY(0deg);
                }
                100% {
                    transform: rotateY(360deg);
                }
            }

            /* Boss Fight Layout */
            .boss-fight-container {
                display: flex;
                gap: 20px;
                max-width: 800px;
                margin: 0 auto;
            }
            .battle-log {
                flex: 1;
                background: #1a1a1a;
                border: 2px solid #333;
                border-radius: 8px;
                padding: 15px;
                max-height: 400px;
                overflow-y: auto;
                font-size: 12px;
                color: #ccc;
            }
            .battle-log h3 {
                margin: 0 0 10px 0;
                color: #5ff9d1;
                font-size: 14px;
                border-bottom: 1px solid #333;
                padding-bottom: 5px;
            }
            .battle-log-entry {
                margin-bottom: 8px;
                padding: 5px;
                border-left: 3px solid #444;
                padding-left: 8px;
            }
            .battle-log-damage {
                border-left-color: #ef4444;
                color: #fca5a5;
            }
            .battle-log-heal {
                border-left-color: #22c55e;
                color: #86efac;
            }
            .battle-log-defense {
                border-left-color: #3b82f6;
                color: #93c5fd;
            }
            .battle-log-calc {
                font-size: 10px;
                color: #888;
                font-style: italic;
                margin-top: 2px;
            }
            .boss-stats {
                flex: 1;
                text-align: center;
            }

            .overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 10;
                text-align: center;
                padding: 20px;
                box-sizing: border-box;
            }
            .overlay h2 {
                color: #5ff9d1;
            }
            .overlay button {
                margin-top: 20px;
                padding: 12px 25px;
                background: #fca311;
                color: #0b0c12;
                border: none;
                border-radius: 8px;
                font-size: 18px;
                cursor: pointer;
                font-weight: bold;
                transition: background 0.2s;
            }
            .overlay button:hover {
                background: #e6910d;
            }

            /* Comic overlay styles (Ver4 inspired) */
            .comic {
                position: absolute;
                inset: 0;
                display: grid;
                place-items: center;
                padding: 18px;
            }
            .panel-box {
                width: min(920px, 95vw);
                height: min(520px, 70vh);
                background: #111429;
                border: 4px solid #1f2a55;
                border-radius: 12px;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
                display: grid;
                grid-template-rows: 1fr auto;
                overflow: hidden;
            }
            .panel-art {
                background: linear-gradient(120deg, #1a2147, #0f1532);
                display: grid;
                place-items: center;
                padding: 16px;
                font-size: 28px;
                position: relative;
            }
            .panel-caption {
                border-top: 2px solid #1f2a55;
                padding: 12px;
                background: #0e1328;
                min-height: 70px;
            }
            .type {
                white-space: pre-wrap;
            }
            .panel-controls {
                position: absolute;
                right: 20px;
                bottom: 16px;
                display: flex;
                gap: 8px;
            }
            .btn {
                background: #3a56ff;
                border: none;
                color: #fff;
                padding: 10px 14px;
                border-radius: 8px;
                cursor: pointer;
            }
            .btn.ghost {
                background: #223;
                color: #aab;
            }
            .blackout {
                position: absolute;
                inset: 0;
                background: #000;
                display: none;
            }

            /* Direction selection area */
            .direction-field {
                position: relative;
                margin: 0 auto;
                width: 200px;
                height: 200px;
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
                grid-template-rows: 1fr 1fr 1fr;
                gap: 10px;
            }
            .dir-zone {
                display: flex;
                align-items: center;
                justify-content: center;
                border: 2px solid #274060;
                border-radius: 8px;
                background: #162033;
                color: #cfeef0;
                font-weight: bold;
                font-size: 14px;
                transition: all 0.2s;
            }
            .dir-zone.active {
                background: #5ff9d1;
                color: #06222a;
                border-color: #5ff9d1;
            }
            .dir-zone.north {
                grid-column: 2;
                grid-row: 1;
            }
            .dir-zone.west {
                grid-column: 1;
                grid-row: 2;
            }
            .dir-zone.center {
                grid-column: 2;
                grid-row: 2;
            }
            .dir-zone.east {
                grid-column: 3;
                grid-row: 2;
            }
            .dir-zone.south {
                grid-column: 2;
                grid-row: 3;
            }

            /* Direction selection specific styles */
            #direction-selection {
                max-width: 600px;
                width: 100%;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                min-height: 400px;
            }

            #direction-selection h2 {
                color: #5ff9d1;
                font-size: 24px;
                margin-bottom: 10px;
            }

            #direction-selection p {
                color: #e5e7eb;
                max-width: 400px;
                margin: 0 auto 30px auto;
            }

            /* Side panel (right) for direction notes */
            #side-panel {
                position: fixed;
                right: 12px;
                top: 80px;
                width: 260px;
                background: #0f1220;
                border: 1px solid #1e2a4b;
                padding: 12px;
                border-radius: 8px;
                color: #e5e7eb;
                z-index: 20;
                font-size: 14px;
            }
            .direction-btn {
                display: inline-block;
                margin: 6px 4px 6px 0;
                padding: 8px 10px;
                border-radius: 6px;
                background: #162033;
                border: 1px solid #274060;
                cursor: pointer;
                color: #cfeef0;
                font-weight: bold;
            }
            .direction-btn.selected {
                background: #5ff9d1;
                color: #06222a;
            }
        </style>
    </head>
    <body>
        <header>
            <h1>MLN122 - Maze of Marx</h1>
            <div class="hud">
                <div class="pill">M·∫°ng s·ªëng ‚ù§Ô∏è: <span id="lives">3</span></div>
                <div class="pill">
                    Ph√≤ng üè†: <span id="room">Ch∆∞∆°ng 1 / 6</span>
                </div>
                <div class="pill">ƒêi·ªÉm s·ªë ‚≠ê: <span id="score">0</span></div>
                <div class="pill">
                    Khi√™n üõ°Ô∏è: <span id="shield-count">0</span>
                </div>
            </div>
        </header>

        <main>
            <canvas id="maze-canvas"></canvas>

            <!-- Modal cho c√¢u h·ªèi v√† ph·∫ßn th∆∞·ªüng (s·ª≠ d·ª•ng chung) -->
            <dialog id="modal-event">
                <div class="modal-content">
                    <h2 id="modal-title">S·ª± ki·ªán</h2>
                    <p id="modal-message">N·ªôi dung s·ª± ki·ªán.</p>
                    <div class="options-box" id="modal-options">
                        <button onclick="closeModal()">ƒê√≥ng</button>
                    </div>
                </div>
            </dialog>

            <!-- Modal cho c√¢u h·ªèi (Ri√™ng) -->
            <dialog id="modal-question">
                <div class="modal-content">
                    <h2 id="question-title">‚ùì C√¢u H·ªèi Kinh T·∫ø Ch√≠nh Tr·ªã</h2>
                    <p id="question-text">ƒê√¢y l√† n·ªôi dung c√¢u h·ªèi.</p>
                    <div class="options-box" id="question-options">
                        <!-- Options will be dynamically inserted here -->
                    </div>
                    <p style="margin-top: 15px; font-size: 12px">
                        ƒê√£ tr·∫£ l·ªùi ƒë√∫ng: <span id="q-correct-count">0</span> /
                        <span id="q-required-count">5</span>
                        <br />
                        S·ªë l·∫ßn th·ª≠: <span id="retry-count">0</span>
                    </p>
                </div>
            </dialog>

            <!-- Overlay (Kh·ªüi ƒë·∫ßu/K·∫øt th√∫c) -->
            <div id="game-overlay" class="overlay" style="display: none">
                <!-- Comic-style intro -->
                <div id="comic-intro" class="comic" style="display: none">
                    <div id="blackout" class="blackout"></div>
                    <div class="panel-box">
                        <div class="panel-art" id="art">üìï</div>
                        <div class="panel-caption">
                            <div class="type" id="caption">ƒêang t·∫£i...</div>
                            <div class="panel-controls">
                                <button id="next-btn" class="btn">
                                    Ti·∫øp ‚Üí
                                </button>
                                <button id="skip-btn" class="btn ghost">
                                    B·ªè qua
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Direction selection -->
                <div id="direction-selection" style="display: none">
                    <div style="text-align: center; margin-bottom: 30px">
                        <h2 style="margin-bottom: 15px">Ch·ªçn H∆∞·ªõng Kh·ªüi ƒê·∫ßu</h2>
                        <p
                            style="
                                margin-bottom: 20px;
                                font-size: 16px;
                                line-height: 1.4;
                            "
                        >
                            Di chuy·ªÉn nh√¢n v·∫≠t (W/A/S/D) ƒë·ªÉ ch·ªçn h∆∞·ªõng, nh·∫•n
                            Space ƒë·ªÉ x√°c nh·∫≠n.
                        </p>
                    </div>
                    <div class="direction-field">
                        <div class="dir-zone north" data-dir="north">
                            B·∫Øc<br />
                        </div>
                        <div class="dir-zone west" data-dir="west">
                            T√¢y<br />
                        </div>
                        <div class="dir-zone center">üü°</div>
                        <div class="dir-zone east" data-dir="east">
                            ƒê√¥ng<br />
                        </div>
                        <div class="dir-zone south" data-dir="south">
                            Nam<br />
                        </div>
                    </div>
                </div>

                <!-- Traditional overlay -->
                <div id="traditional-overlay">
                    <h2 id="overlay-title">B·∫Øt ƒê·∫ßu H√†nh Tr√¨nh</h2>
                    <p id="overlay-message">
                        Di chuy·ªÉn b·∫±ng W, A, S, D ho·∫∑c ph√≠m m≈©i t√™n. V∆∞·ª£t t∆∞·ªùng
                        b·∫±ng c√°ch di chuy·ªÉn v√†o t∆∞·ªùng (t·ªën 10 ƒëi·ªÉm).
                    </p>
                    <button onclick="startGame()">B·∫Øt ƒê·∫ßu</button>
                </div>
            </div>
        </main>

        <!-- Side panel for direction notes -->
        <aside id="side-panel">
            <h3 id="panel-title">Ch·ªçn h∆∞·ªõng ban ƒë·∫ßu</h3>
            <div id="direction-buttons" style="margin-bottom: 8px">
                <button class="direction-btn" data-dir="east">ƒê√¥ng</button>
                <button class="direction-btn" data-dir="west">T√¢y</button>
                <button class="direction-btn" data-dir="north">B·∫Øc</button>
                <button class="direction-btn" data-dir="south">Nam</button>
            </div>
            <div
                id="direction-locked"
                style="display: none; margin-bottom: 8px"
            >
                <div
                    class="pill"
                    style="
                        background: #5ff9d1;
                        color: #06222a;
                        padding: 8px 12px;
                    "
                >
                    <strong
                        >H∆∞·ªõng ƒë√£ ch·ªçn:
                        <span id="locked-direction">---</span></strong
                    >
                </div>
            </div>
            <div id="side-notes">
                Ch∆∞a ch·ªçn h∆∞·ªõng. H√£y ch·ªçn 1 h∆∞·ªõng tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu.
            </div>
            <div style="margin-top: 10px; font-size: 12px; color: #9ca3af">
                <span id="space-hint"
                    >·∫§n Space ƒë·ªÉ b·∫≠t/t·∫Øt ch·∫ø ƒë·ªô mu·ªën v∆∞·ª£t t∆∞·ªùng (khi b·∫≠t, nh·∫•n
                    v√†o t∆∞·ªùng ƒë·ªÉ xuy√™n).</span
                >
            </div>
        </aside>

        <script>
            // Bi·∫øn to√†n c·ª•c t·ª´ Canvas (gi·∫£ ƒë·ªãnh)
            const appId =
                typeof __app_id !== "undefined" ? __app_id : "default-app-id";

            // --- 1. C·∫•u h√¨nh v√† Icon h√≥a ---
            const canvas = document.getElementById("maze-canvas");
            const ctx = canvas.getContext("2d");

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // GAME BALANCE CONFIGURATION
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            const GAME_CONFIG = {
                // C·∫•u h√¨nh m√™ cung
                MAZE_SIZE: 15, // K√≠ch th∆∞·ªõc l∆∞·ªõi m√™ cung (NxN)
                CELL_SIZE: 40, // K√≠ch th∆∞·ªõc pixel c·ªßa m·ªói √¥
                SPEED: 1, // B∆∞·ªõc di chuy·ªÉn m·ªói l·∫ßn

                // C·∫•u h√¨nh ng∆∞·ªùi ch∆°i
                MAX_LIVES: 3, // S·ªë m·∫°ng t·ªëi ƒëa

                // C·∫•u h√¨nh ƒëi·ªÉm s·ªë
                BASE_POINTS: 10, // ƒêi·ªÉm c∆° b·∫£n m·ªói c√¢u h·ªèi
                EAST_BONUS_POINTS: 15, // ƒêi·ªÉm th∆∞·ªüng khi ch·ªçn h∆∞·ªõng ƒê√¥ng
                MIN_POINTS_PER_QUESTION: 1, // ƒêi·ªÉm t·ªëi thi·ªÉu m·ªói c√¢u (sau penalty)

                // C·∫•u h√¨nh ph·∫ßn th∆∞·ªüng
                TREASURE_SMALL_REWARD: 20, // ƒêi·ªÉm th∆∞·ªüng r∆∞∆°ng nh·ªè
                TREASURE_BIG_REWARD: 50, // ƒêi·ªÉm th∆∞·ªüng r∆∞∆°ng l·ªõn
                DICE_BET_COST: 5, // Chi ph√≠ ch∆°i x√∫c x·∫Øc
                DICE_WIN_REWARD: 10, // Ph·∫ßn th∆∞·ªüng th·∫Øng x√∫c x·∫Øc (5 c∆∞·ª£c + 5 th·∫Øng)

                // C·∫•u h√¨nh t∆∞·ªùng v√† di chuy·ªÉn
                WALL_BYPASS_COST: 5, // Chi ph√≠ xuy√™n t∆∞·ªùng

                // C·∫•u h√¨nh c√¢u h·ªèi v√† ch∆∞∆°ng
                TOTAL_CHAPTERS: 6, // T·ªïng s·ªë ch∆∞∆°ng
                QUESTIONS_PER_CHAPTER: 10, // S·ªë c√¢u h·ªèi m·ªói ch∆∞∆°ng
                MIN_CORRECT_TO_PROGRESS: 5, // S·ªë c√¢u ƒë√∫ng t·ªëi thi·ªÉu ƒë·ªÉ qua ch∆∞∆°ng
                MAX_EVENTS_PER_MAZE: 10, // T·ªïng s·ªë s·ª± ki·ªán m·ªói m√™ cung

                // C·∫•u h√¨nh c√°c lo·∫°i s·ª± ki·ªán
                MIN_REWARDS_PER_MAZE: 1, // S·ªë r∆∞∆°ng th∆∞·ªüng t·ªëi thi·ªÉu m·ªói m√™ cung
                MAX_REWARDS_PER_MAZE: 3, // S·ªë r∆∞∆°ng th∆∞·ªüng t·ªëi ƒëa m·ªói m√™ cung
                SHIELDS_PER_MAZE: 2, // S·ªë khi√™n m·ªói m√™ cung
                EXTRA_SHIELDS_WEST: 2, // Khi√™n th√™m khi ch·ªçn h∆∞·ªõng T√¢y
                EXTRA_SHIELDS_SOUTH: 1, // Khi√™n th√™m khi ch·ªçn h∆∞·ªõng Nam

                // C·∫•u h√¨nh x√∫c x·∫Øc
                DICE_SIDES: 6, // S·ªë m·∫∑t x√∫c x·∫Øc

                // C·∫•u h√¨nh Boss Fight
                BOSS_HEALTH: 999, // M√°u boss
                BOSS_MIN_DAMAGE: 15, // S√°t th∆∞∆°ng t·ªëi thi·ªÉu c·ªßa boss
                BOSS_MAX_DAMAGE: 25, // S√°t th∆∞∆°ng t·ªëi ƒëa c·ªßa boss
                PLAYER_ATTACK_BASE: 20, // S√°t th∆∞∆°ng c∆° b·∫£n c·ªßa player
                PLAYER_ATTACK_BONUS_PER_10_POINTS: 5, // Th√™m s√°t th∆∞∆°ng m·ªói 10 ƒëi·ªÉm
                BOSS_VICTORY_REWARD: 100, // Ph·∫ßn th∆∞·ªüng khi th·∫Øng boss
            };

            // S·ª≠ d·ª•ng c√°c gi√° tr·ªã c·∫•u h√¨nh (ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c)
            const N = GAME_CONFIG.MAZE_SIZE;
            const SPEED = GAME_CONFIG.SPEED;
            const CELL_SIZE = GAME_CONFIG.CELL_SIZE;
            const MAX_LIVES = GAME_CONFIG.MAX_LIVES;
            const WALL_BYPASS_COST = GAME_CONFIG.WALL_BYPASS_COST;
            const MAX_EVENTS = GAME_CONFIG.MAX_EVENTS_PER_MAZE;
            const QUESTIONS_MIN = GAME_CONFIG.MIN_CORRECT_TO_PROGRESS;
            const QUESTIONS_MAX = GAME_CONFIG.QUESTIONS_PER_CHAPTER;

            // H·∫±ng s·ªë Icon (SVG)
            // L∆ØU √ù: ƒê√¢y l√† m√£ SVG/HTML, ƒë∆∞·ª£c ch√®n v√†o canvas th√¥ng qua DOM ho·∫∑c drawImage
            const ICON_QUESTION_SVG =
                '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#5ff9d1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-help-circle"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg>'; // √î c√¢u h·ªèi (2)
            const ICON_REWARD_SVG =
                '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#fca311" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-gift"><polyline points="20 12 12 12 12 20"/><path d="M20 13V6a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h7"/></svg>'; // √î th∆∞·ªüng m·ªõi (3)
            const ICON_SHIELD_SVG =
                '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#60a5fa" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-shield"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>'; // V·∫≠t ph·∫©m khi√™n (4)
            const ICON_EXIT_SVG =
                '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-castle"><path d="M22 17a2 2 0 0 0-2-2v-2h-3V7l-5-5-5 5v6H4v2a2 2 0 0 0-2 2h20Z"/><path d="M2 17v3h3"/><path d="M17 17v3h5"/><path d="M15 12V9"/><path d="M9 12V9"/></svg>'; // L·ªëi tho√°t cu·ªëi game (5)
            const ICON_CHAPTER_EXIT_SVG =
                '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#9333ea" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-portal"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>'; // C·ªïng chuy·ªÉn ch∆∞∆°ng (6)
            const ICON_BOSS_SVG =
                '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#dc2626" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-crown"><path d="m2 4 3 12h14l3-12-6 7-4-7-4 7-6-7zm7 16h6"/></svg>'; // Boss Mr.Ph√∫c (7)

            // C·∫ßn t·∫°o ƒë·ªëi t∆∞·ª£ng Image cho m·ªói icon ƒë·ªÉ v·∫Ω l√™n Canvas
            const iconImages = {};
            const iconData = {
                2: { svg: ICON_QUESTION_SVG, color: "#5ff9d1" },
                3: { svg: ICON_REWARD_SVG, color: "#fca311" },
                4: { svg: ICON_SHIELD_SVG, color: "#60a5fa" },
                5: { svg: ICON_EXIT_SVG, color: "#ef4444" },
                6: { svg: ICON_CHAPTER_EXIT_SVG, color: "#9333ea" },
                7: { svg: ICON_BOSS_SVG, color: "#dc2626" },
            };

            // H√†m chuy·ªÉn SVG sang ƒë·ªëi t∆∞·ª£ng Image ƒë·ªÉ v·∫Ω l√™n Canvas
            function loadIcons() {
                Object.keys(iconData).forEach((key) => {
                    const img = new Image();
                    // ƒê·ªÉ v·∫Ω SVG l√™n canvas, ta c·∫ßn chuy·ªÉn n√≥ th√†nh Data URL
                    const svgData = `<svg xmlns="http://www.w3.org/2000/svg" width="${CELL_SIZE}" height="${CELL_SIZE}" viewBox="0 0 24 24">${iconData[
                        key
                    ].svg
                        .split(">")
                        .slice(1)
                        .join(">")
                        .replace("</svg>", "")}</svg>`;
                    img.src =
                        "data:image/svg+xml;base64," +
                        btoa(unescape(encodeURIComponent(svgData)));
                    iconImages[key] = img;
                });
            }

            // C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc canvas
            canvas.width = N * CELL_SIZE;
            canvas.height = N * CELL_SIZE;

            // D·ªØ li·ªáu tr√≤ ch∆°i
            let player = { x: 1, y: 1, lives: MAX_LIVES, score: 0, shield: 0 };
            let maze = [];
            let gameEvents = [];
            let isGameRunning = false;
            // New gameplay state
            let chosenDirection = null; // 'east'|'west'|'north'|'south'
            let directionLocked = false; // once game starts, direction cannot be changed
            let bypassFlag = false; // toggled by Space

            // Ver4-style room system - 6 chapters
            let currentRoomIndex = 1; // starts at room 1/6
            let totalRooms = GAME_CONFIG.TOTAL_CHAPTERS;
            let roomData = null;
            let chapterQuestionsCorrect = 0; // Track correct answers in current chapter

            // Mini-room state (when entering event-specific small mazes)
            let inRoom = false;
            let currentRoom = null;
            let roomPlayer = null;

            // Intro system state
            let introMode = "comic"; // 'comic' | 'direction' | 'done'
            let panelIndex = 0;
            let typingId = null;
            let selectorPlayer = { x: 1, y: 1 }; // player position in direction selector

            // D·ªØ li·ªáu c√¢u h·ªèi theo t·ª´ng ch∆∞∆°ng Kinh t·∫ø ch√≠nh tr·ªã M√°c-L√™nin
            const questionsByChapter = {
                1: [
                    // Ch∆∞∆°ng I: T·ªïng quan v·ªÅ Kinh t·∫ø Ch√≠nh tr·ªã M√°c-L√™nin
                    {
                        q: "ƒê·ªëi t∆∞·ª£ng nghi√™n c·ª©u c·ªßa Kinh t·∫ø ch√≠nh tr·ªã M√°c-L√™nin l√† g√¨?",
                        options: [
                            "Quan h·ªá s·∫£n xu·∫•t",
                            "L·ª±c l∆∞·ª£ng s·∫£n xu·∫•t",
                            "Ph∆∞∆°ng th·ª©c s·∫£n xu·∫•t",
                            "T·∫•t c·∫£ c√°c ƒë√°p √°n tr√™n",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Ph∆∞∆°ng ph√°p nghi√™n c·ª©u c∆° b·∫£n c·ªßa Kinh t·∫ø ch√≠nh tr·ªã M√°c-L√™nin l√† g√¨?",
                        options: [
                            "Duy v·∫≠t bi·ªán ch·ª©ng",
                            "Duy t√¢m bi·ªán ch·ª©ng",
                            "Si√™u h√¨nh h·ªçc",
                            "Th·ª±c nghi·ªám",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Quy lu·∫≠t c∆° b·∫£n nh·∫•t chi ph·ªëi s·ª± v·∫≠n ƒë·ªông c·ªßa c√°c h√¨nh th√°i kinh t·∫ø-x√£ h·ªôi l√† g√¨?",
                        options: [
                            "Quy lu·∫≠t gi√° tr·ªã",
                            "Quy lu·∫≠t cung c·∫ßu",
                            "Quy lu·∫≠t ph√π h·ª£p c·ªßa quan h·ªá s·∫£n xu·∫•t v·ªõi tr√¨nh ƒë·ªô ph√°t tri·ªÉn c·ªßa l·ª±c l∆∞·ª£ng s·∫£n xu·∫•t",
                            "Quy lu·∫≠t c·∫°nh tranh",
                        ],
                        answer: 2,
                    },
                    {
                        q: "L·ª±c l∆∞·ª£ng s·∫£n xu·∫•t bao g·ªìm nh·ªØng y·∫øu t·ªë n√†o?",
                        options: [
                            "Ng∆∞·ªùi lao ƒë·ªông v√† t∆∞ li·ªáu s·∫£n xu·∫•t",
                            "Quan h·ªá s·∫£n xu·∫•t",
                            "√ù th·ª©c x√£ h·ªôi",
                            "Ki·∫øn tr√∫c th∆∞·ª£ng t·∫ßng",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Quan h·ªá s·∫£n xu·∫•t l√† quan h·ªá gi·ªØa?",
                        options: [
                            "Ng∆∞·ªùi v·ªõi t·ª± nhi√™n",
                            "Ng∆∞·ªùi v·ªõi ng∆∞·ªùi trong qu√° tr√¨nh s·∫£n xu·∫•t",
                            "Ng∆∞·ªùi v·ªõi c√¥ng ngh·ªá",
                            "Ng∆∞·ªùi v·ªõi th·ªã tr∆∞·ªùng",
                        ],
                        answer: 1,
                    },
                    {
                        q: "C∆° s·ªü h·∫° t·∫ßng kinh t·∫ø bao g·ªìm?",
                        options: [
                            "L·ª±c l∆∞·ª£ng s·∫£n xu·∫•t v√† quan h·ªá s·∫£n xu·∫•t",
                            "Ch·ªâ l·ª±c l∆∞·ª£ng s·∫£n xu·∫•t",
                            "Ch·ªâ quan h·ªá s·∫£n xu·∫•t",
                            "√ù th·ª©c x√£ h·ªôi",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Ki·∫øn tr√∫c th∆∞·ª£ng t·∫ßng x√£ h·ªôi bao g·ªìm?",
                        options: [
                            "Quan h·ªá s·∫£n xu·∫•t",
                            "C√°c quan h·ªá ch√≠nh tr·ªã, ph√°p l√Ω v√† √Ω th·ª©c x√£ h·ªôi",
                            "L·ª±c l∆∞·ª£ng s·∫£n xu·∫•t",
                            "T∆∞ li·ªáu s·∫£n xu·∫•t",
                        ],
                        answer: 1,
                    },
                    {
                        q: "H√¨nh th√°i kinh t·∫ø-x√£ h·ªôi l√† g√¨?",
                        options: [
                            "Ch·ªâ c∆° s·ªü h·∫° t·∫ßng",
                            "Ch·ªâ ki·∫øn tr√∫c th∆∞·ª£ng t·∫ßng",
                            "S·ª± th·ªëng nh·∫•t gi·ªØa c∆° s·ªü h·∫° t·∫ßng v√† ki·∫øn tr√∫c th∆∞·ª£ng t·∫ßng",
                            "L·ª±c l∆∞·ª£ng s·∫£n xu·∫•t",
                        ],
                        answer: 2,
                    },
                    {
                        q: "ƒê·ªông l·ª±c ph√°t tri·ªÉn x√£ h·ªôi l√† g√¨?",
                        options: [
                            "M√¢u thu·∫´n gi·ªØa l·ª±c l∆∞·ª£ng s·∫£n xu·∫•t v√† quan h·ªá s·∫£n xu·∫•t",
                            "C·∫°nh tranh",
                            "ƒê·ªïi m·ªõi c√¥ng ngh·ªá",
                            "Ch√≠nh s√°ch nh√† n∆∞·ªõc",
                        ],
                        answer: 0,
                    },
                    {
                        q: "T√≠nh quy lu·∫≠t kh√°ch quan c·ªßa l·ªãch s·ª≠ c√≥ nghƒ©a l√† g√¨?",
                        options: [
                            "Con ng∆∞·ªùi kh√¥ng th·ªÉ t√°c ƒë·ªông v√†o l·ªãch s·ª≠",
                            "L·ªãch s·ª≠ ph√°t tri·ªÉn theo √Ω mu·ªën ch·ªß quan",
                            "L·ªãch s·ª≠ ph√°t tri·ªÉn theo nh·ªØng quy lu·∫≠t kh√°ch quan, ƒë·ªôc l·∫≠p v·ªõi √Ω th·ª©c con ng∆∞·ªùi",
                            "L·ªãch s·ª≠ ƒë∆∞·ª£c quy·∫øt ƒë·ªãnh b·ªüi thi√™n nhi√™n",
                        ],
                        answer: 2,
                    },
                ],
                2: [
                    // Ch∆∞∆°ng II: H√†ng h√≥a, th·ªã tr∆∞·ªùng v√† vai tr√≤ c·ªßa c√°c ch·ªß th·ªÉ tham gia th·ªã tr∆∞·ªùng
                    {
                        q: "H√†ng h√≥a l√† g√¨?",
                        options: [
                            "S·∫£n ph·∫©m lao ƒë·ªông",
                            "S·∫£n ph·∫©m lao ƒë·ªông ƒë·ªÉ trao ƒë·ªïi",
                            "V·∫≠t c√≥ √≠ch",
                            "T·∫•t c·∫£ ƒë·ªÅu ƒë√∫ng",
                        ],
                        answer: 1,
                    },
                    {
                        q: "Hai thu·ªôc t√≠nh c∆° b·∫£n c·ªßa h√†ng h√≥a l√† g√¨?",
                        options: [
                            "Gi√° tr·ªã s·ª≠ d·ª•ng v√† gi√° tr·ªã trao ƒë·ªïi",
                            "Gi√° tr·ªã s·ª≠ d·ª•ng v√† gi√° tr·ªã",
                            "Gi√° tr·ªã v√† gi√° c·∫£",
                            "Ch·∫•t l∆∞·ª£ng v√† s·ªë l∆∞·ª£ng",
                        ],
                        answer: 1,
                    },
                    {
                        q: "Gi√° tr·ªã c·ªßa h√†ng h√≥a ƒë∆∞·ª£c quy·∫øt ƒë·ªãnh b·ªüi?",
                        options: [
                            "Th·ªùi gian lao ƒë·ªông c√° bi·ªát",
                            "Th·ªùi gian lao ƒë·ªông x√£ h·ªôi c·∫ßn thi·∫øt",
                            "Gi√° c·∫£ th·ªã tr∆∞·ªùng",
                            "Chi ph√≠ s·∫£n xu·∫•t",
                        ],
                        answer: 1,
                    },
                    {
                        q: "Ti·ªÅn t·ªá xu·∫•t hi·ªán t·ª´?",
                        options: [
                            "Quy·∫øt ƒë·ªãnh c·ªßa nh√† n∆∞·ªõc",
                            "S·ª± ph√°t tri·ªÉn c·ªßa trao ƒë·ªïi h√†ng h√≥a",
                            "Nhu c·∫ßu c·ªßa con ng∆∞·ªùi",
                            "Khoa h·ªçc c√¥ng ngh·ªá",
                        ],
                        answer: 1,
                    },
                    {
                        q: "C√°c ch·ª©c nƒÉng c∆° b·∫£n c·ªßa ti·ªÅn t·ªá l√†?",
                        options: [
                            "Th∆∞·ªõc ƒëo gi√° tr·ªã, ph∆∞∆°ng ti·ªán l∆∞u th√¥ng, ph∆∞∆°ng ti·ªán thanh to√°n, ph∆∞∆°ng ti·ªán t√≠ch tr·ªØ",
                            "Ch·ªâ th∆∞·ªõc ƒëo gi√° tr·ªã",
                            "Ch·ªâ ph∆∞∆°ng ti·ªán l∆∞u th√¥ng",
                            "Ch·ªâ ƒë·ªÉ t√≠ch tr·ªØ",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Th·ªã tr∆∞·ªùng l√† g√¨?",
                        options: [
                            "N∆°i mua b√°n h√†ng h√≥a",
                            "T·ªïng th·ªÉ c√°c quan h·ªá trao ƒë·ªïi h√†ng h√≥a",
                            "C·ª≠a h√†ng",
                            "Khu v·ª±c ƒë·ªãa l√Ω",
                        ],
                        answer: 1,
                    },
                    {
                        q: "Quy lu·∫≠t gi√° tr·ªã bi·ªÉu hi·ªán nh∆∞ th·∫ø n√†o?",
                        options: [
                            "Gi√° c·∫£ dao ƒë·ªông quanh gi√° tr·ªã",
                            "Gi√° c·∫£ lu√¥n b·∫±ng gi√° tr·ªã",
                            "Gi√° c·∫£ cao h∆°n gi√° tr·ªã",
                            "Gi√° c·∫£ th·∫•p h∆°n gi√° tr·ªã",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Vai tr√≤ t√≠ch c·ª±c c·ªßa quy lu·∫≠t gi√° tr·ªã trong n·ªÅn kinh t·∫ø h√†ng h√≥a l√† g√¨?",
                        options: [
                            "ƒêi·ªÅu ti·∫øt s·∫£n xu·∫•t",
                            "K√≠ch th√≠ch n√¢ng cao nƒÉng su·∫•t lao ƒë·ªông",
                            "Ph√¢n h√≥a ng∆∞·ªùi s·∫£n xu·∫•t h√†ng h√≥a nh·ªè",
                            "C·∫£ A v√† B",
                        ],
                        answer: 3,
                    },
                    {
                        q: "C√°c ch·ªß th·ªÉ tham gia th·ªã tr∆∞·ªùng bao g·ªìm?",
                        options: [
                            "H·ªô gia ƒë√¨nh, doanh nghi·ªáp, ch√≠nh ph·ªß",
                            "Ch·ªâ doanh nghi·ªáp",
                            "Ch·ªâ h·ªô gia ƒë√¨nh",
                            "Ch·ªâ ch√≠nh ph·ªß",
                        ],
                        answer: 0,
                    },
                    {
                        q: "C∆° ch·∫ø th·ªã tr∆∞·ªùng ho·∫°t ƒë·ªông d·ª±a tr√™n?",
                        options: [
                            "K·∫ø ho·∫°ch nh√† n∆∞·ªõc",
                            "Quan h·ªá cung c·∫ßu v√† gi√° c·∫£",
                            "√ù mu·ªën ch·ªß quan",
                            "Truy·ªÅn th·ªëng",
                        ],
                        answer: 1,
                    },
                ],
                3: [
                    // Ch∆∞∆°ng III: Gi√° tr·ªã th·∫∑ng d∆∞ trong n·ªÅn kinh t·∫ø th·ªã tr∆∞·ªùng
                    {
                        q: "Gi√° tr·ªã th·∫∑ng d∆∞ l√† g√¨?",
                        options: [
                            "Ph·∫ßn gi√° tr·ªã m·ªõi do ng∆∞·ªùi c√¥ng nh√¢n t·∫°o ra v∆∞·ª£t qu√° gi√° tr·ªã s·ª©c lao ƒë·ªông",
                            "L·ª£i nhu·∫≠n c·ªßa doanh nghi·ªáp",
                            "Ti·ªÅn l∆∞∆°ng c·ªßa c√¥ng nh√¢n",
                            "Chi ph√≠ s·∫£n xu·∫•t",
                        ],
                        answer: 0,
                    },
                    {
                        q: "ƒêi·ªÅu ki·ªán h√¨nh th√†nh gi√° tr·ªã th·∫∑ng d∆∞ l√† g√¨?",
                        options: [
                            "T·ªìn t·∫°i s·ªü h·ªØu t∆∞ nh√¢n v·ªÅ t∆∞ li·ªáu s·∫£n xu·∫•t",
                            "S·ª©c lao ƒë·ªông tr·ªü th√†nh h√†ng h√≥a",
                            "C·∫£ A v√† B",
                            "Ch·ªâ c√≥ c√¥ng ngh·ªá cao",
                        ],
                        answer: 2,
                    },
                    {
                        q: "Gi√° tr·ªã th·∫∑ng d∆∞ tuy·ªát ƒë·ªëi ƒë∆∞·ª£c t·∫°o ra b·∫±ng c√°ch n√†o?",
                        options: [
                            "K√©o d√†i th·ªùi gian lao ƒë·ªông",
                            "N√¢ng cao nƒÉng su·∫•t lao ƒë·ªông",
                            "Gi·∫£m ti·ªÅn l∆∞∆°ng",
                            "TƒÉng gi√° b√°n",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Gi√° tr·ªã th·∫∑ng d∆∞ t∆∞∆°ng ƒë·ªëi ƒë∆∞·ª£c t·∫°o ra b·∫±ng c√°ch n√†o?",
                        options: [
                            "K√©o d√†i th·ªùi gian lao ƒë·ªông",
                            "R√∫t ng·∫Øn th·ªùi gian lao ƒë·ªông c·∫ßn thi·∫øt",
                            "Gi·∫£m ti·ªÅn l∆∞∆°ng",
                            "TƒÉng gi√° b√°n",
                        ],
                        answer: 1,
                    },
                    {
                        q: "T·ª∑ su·∫•t gi√° tr·ªã th·∫∑ng d∆∞ ƒë∆∞·ª£c t√≠nh b·∫±ng?",
                        options: ["m/v", "m/c", "m/(c+v)", "v/m"],
                        answer: 0,
                    },
                    {
                        q: "T∆∞ b·∫£n b·∫•t bi·∫øn (c) l√† g√¨?",
                        options: [
                            "Ph·∫ßn t∆∞ b·∫£n d√πng mua s·ª©c lao ƒë·ªông",
                            "Ph·∫ßn t∆∞ b·∫£n d√πng mua t∆∞ li·ªáu s·∫£n xu·∫•t",
                            "To√†n b·ªô t∆∞ b·∫£n",
                            "L·ª£i nhu·∫≠n",
                        ],
                        answer: 1,
                    },
                    {
                        q: "T∆∞ b·∫£n kh·∫£ bi·∫øn (v) l√† g√¨?",
                        options: [
                            "Ph·∫ßn t∆∞ b·∫£n d√πng mua t∆∞ li·ªáu s·∫£n xu·∫•t",
                            "Ph·∫ßn t∆∞ b·∫£n d√πng mua s·ª©c lao ƒë·ªông",
                            "To√†n b·ªô t∆∞ b·∫£n",
                            "Gi√° tr·ªã th·∫∑ng d∆∞",
                        ],
                        answer: 1,
                    },
                    {
                        q: "T·ª∑ su·∫•t l·ª£i nhu·∫≠n ƒë∆∞·ª£c t√≠nh b·∫±ng?",
                        options: ["m/v", "m/(c+v)", "m/c", "v/c"],
                        answer: 1,
                    },
                    {
                        q: "Quy lu·∫≠t t·ª∑ su·∫•t l·ª£i nhu·∫≠n c√≥ xu h∆∞·ªõng gi·∫£m d·∫ßn ƒë∆∞·ª£c Marx ph√°t hi·ªán d·ª±a tr√™n?",
                        options: [
                            "S·ª± gia tƒÉng c·∫•u t·∫°o h·ªØu c∆° c·ªßa t∆∞ b·∫£n",
                            "S·ª± gi·∫£m nƒÉng su·∫•t lao ƒë·ªông",
                            "S·ª± tƒÉng ti·ªÅn l∆∞∆°ng",
                            "S·ª± gi·∫£m gi√° h√†ng h√≥a",
                        ],
                        answer: 0,
                    },
                    {
                        q: "B·∫£n ch·∫•t c·ªßa ch·∫ø ƒë·ªô t∆∞ b·∫£n ch·ªß nghƒ©a l√† g√¨?",
                        options: [
                            "B√≥c l·ªôt gi√° tr·ªã th·∫∑ng d∆∞",
                            "Ph√°t tri·ªÉn kinh t·∫ø",
                            "T·ª± do kinh doanh",
                            "C·∫°nh tranh c√¥ng b·∫±ng",
                        ],
                        answer: 0,
                    },
                ],
                4: [
                    // Ch∆∞∆°ng IV: C·∫°nh tranh v√† ƒë·ªôc quy·ªÅn trong n·ªÅn kinh t·∫ø th·ªã tr∆∞·ªùng
                    {
                        q: "C·∫°nh tranh t·ª± do l√† g√¨?",
                        options: [
                            "C·∫°nh tranh kh√¥ng c√≥ s·ª± can thi·ªáp c·ªßa nh√† n∆∞·ªõc",
                            "C·∫°nh tranh gi·ªØa c√°c doanh nghi·ªáp nh·ªè",
                            "C·∫°nh tranh trong ƒëi·ªÅu ki·ªán kh√¥ng c√≥ ƒë·ªôc quy·ªÅn",
                            "T·∫•t c·∫£ ƒë·ªÅu ƒë√∫ng",
                        ],
                        answer: 2,
                    },
                    {
                        q: "ƒê·ªôc quy·ªÅn t∆∞ b·∫£n ch·ªß nghƒ©a xu·∫•t hi·ªán t·ª´?",
                        options: [
                            "Quy·∫øt ƒë·ªãnh c·ªßa nh√† n∆∞·ªõc",
                            "S·ª± ph√°t tri·ªÉn c·ªßa c·∫°nh tranh t·ª± do",
                            "Khoa h·ªçc c√¥ng ngh·ªá",
                            "√ù mu·ªën c·ªßa t∆∞ b·∫£n gia",
                        ],
                        answer: 1,
                    },
                    {
                        q: "C√°c h√¨nh th·ª©c ƒë·ªôc quy·ªÅn ch·ªß y·∫øu bao g·ªìm?",
                        options: [
                            "Cartel, Syndicate, Trust, Concern",
                            "Ch·ªâ Cartel",
                            "Ch·ªâ Trust",
                            "Ch·ªâ Concern",
                        ],
                        answer: 0,
                    },
                    {
                        q: "L·ª£i nhu·∫≠n ƒë·ªôc quy·ªÅn ƒë∆∞·ª£c h√¨nh th√†nh t·ª´?",
                        options: [
                            "Gi√° ƒë·ªôc quy·ªÅn cao h∆°n gi√° tr·ªã",
                            "NƒÉng su·∫•t lao ƒë·ªông cao",
                            "Chi ph√≠ s·∫£n xu·∫•t th·∫•p",
                            "Ch·∫•t l∆∞·ª£ng s·∫£n ph·∫©m t·ªët",
                        ],
                        answer: 0,
                    },
                    {
                        q: "T∆∞ b·∫£n t√†i ch√≠nh l√† g√¨?",
                        options: [
                            "S·ª± k·∫øt h·ª£p gi·ªØa t∆∞ b·∫£n c√¥ng nghi·ªáp v√† t∆∞ b·∫£n ng√¢n h√†ng",
                            "Ch·ªâ t∆∞ b·∫£n ng√¢n h√†ng",
                            "Ch·ªâ t∆∞ b·∫£n c√¥ng nghi·ªáp",
                            "T∆∞ b·∫£n th∆∞∆°ng m·∫°i",
                        ],
                        answer: 0,
                    },
                    {
                        q: "M√¢u thu·∫´n c∆° b·∫£n c·ªßa ch·ªß nghƒ©a t∆∞ b·∫£n ƒë·ªôc quy·ªÅn l√† g√¨?",
                        options: [
                            "Gi·ªØa t√≠nh ch·∫•t x√£ h·ªôi c·ªßa s·∫£n xu·∫•t v√† chi·∫øm h·ªØu t∆∞ nh√¢n",
                            "Gi·ªØa c√°c t·∫≠p ƒëo√†n ƒë·ªôc quy·ªÅn",
                            "Gi·ªØa nh√† n∆∞·ªõc v√† doanh nghi·ªáp",
                            "Gi·ªØa lao ƒë·ªông v√† t∆∞ b·∫£n",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Cu·ªôc kh·ªßng ho·∫£ng kinh t·∫ø chu k·ª≥ trong ch·ªß nghƒ©a t∆∞ b·∫£n l√† bi·ªÉu hi·ªán c·ªßa?",
                        options: [
                            "Thi√™n tai",
                            "Chi·∫øn tranh",
                            "M√¢u thu·∫´n c∆° b·∫£n c·ªßa ch·∫ø ƒë·ªô t∆∞ b·∫£n ch·ªß nghƒ©a",
                            "Ch√≠nh s√°ch sai l·∫ßm",
                        ],
                        answer: 2,
                    },
                    {
                        q: "C√°c giai ƒëo·∫°n c·ªßa chu k·ª≥ kh·ªßng ho·∫£ng kinh t·∫ø t∆∞ b·∫£n ch·ªß nghƒ©a?",
                        options: [
                            "Kh·ªßng ho·∫£ng, tr·∫ßm l·∫Øng, ph·ª•c h·ªìi, ph·ªìn vinh",
                            "Ch·ªâ c√≥ kh·ªßng ho·∫£ng",
                            "Ch·ªâ c√≥ ph·ªìn vinh",
                            "Kh·ªßng ho·∫£ng v√† ph·ª•c h·ªìi",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Nguy√™n nh√¢n s√¢u xa c·ªßa kh·ªßng ho·∫£ng kinh t·∫ø t∆∞ b·∫£n ch·ªß nghƒ©a l√† g√¨?",
                        options: [
                            "S·∫£n xu·∫•t qu√° m·ª©c",
                            "Ti√™u d√πng kh√¥ng ƒë·ªß",
                            "M√¢u thu·∫´n gi·ªØa t√≠nh ch·∫•t x√£ h·ªôi c·ªßa s·∫£n xu·∫•t v√† chi·∫øm h·ªØu t∆∞ nh√¢n",
                            "C·∫°nh tranh qu√° kh·ªëc li·ªát",
                        ],
                        answer: 2,
                    },
                    {
                        q: "Vai tr√≤ c·ªßa nh√† n∆∞·ªõc trong n·ªÅn kinh t·∫ø th·ªã tr∆∞·ªùng hi·ªán ƒë·∫°i?",
                        options: [
                            "Kh√¥ng can thi·ªáp",
                            "Can thi·ªáp to√†n di·ªán",
                            "Can thi·ªáp ƒë·ªÉ ƒëi·ªÅu ti·∫øt v√† kh·∫Øc ph·ª•c khuy·∫øt t·∫≠t c·ªßa th·ªã tr∆∞·ªùng",
                            "Ch·ªâ thu thu·∫ø",
                        ],
                        answer: 2,
                    },
                ],
                5: [
                    // Ch∆∞∆°ng V: Kinh t·∫ø th·ªã tr∆∞·ªùng ƒë·ªãnh h∆∞·ªõng x√£ h·ªôi ch·ªß nghƒ©a v√† c√°c quan h·ªá l·ª£i √≠ch kinh t·∫ø ·ªü Vi·ªát Nam
                    {
                        q: "ƒê·∫∑c trung c∆° b·∫£n c·ªßa kinh t·∫ø th·ªã tr∆∞·ªùng ƒë·ªãnh h∆∞·ªõng x√£ h·ªôi ch·ªß nghƒ©a ·ªü Vi·ªát Nam l√† g√¨?",
                        options: [
                            "ƒêa s·ªü h·ªØu v·ªõi vai tr√≤ ch·ªß ƒë·∫°o c·ªßa kinh t·∫ø nh√† n∆∞·ªõc",
                            "Ch·ªâ c√≥ kinh t·∫ø nh√† n∆∞·ªõc",
                            "Ch·ªâ c√≥ kinh t·∫ø t∆∞ nh√¢n",
                            "Kh√¥ng c√≥ s·ª± ƒëi·ªÅu ti·∫øt c·ªßa nh√† n∆∞·ªõc",
                        ],
                        answer: 0,
                    },
                    {
                        q: "C√°c th√†nh ph·∫ßn kinh t·∫ø trong n·ªÅn kinh t·∫ø Vi·ªát Nam hi·ªán nay?",
                        options: [
                            "Kinh t·∫ø nh√† n∆∞·ªõc, kinh t·∫ø t·∫≠p th·ªÉ, kinh t·∫ø t∆∞ nh√¢n, kinh t·∫ø c√≥ v·ªën ƒë·∫ßu t∆∞ n∆∞·ªõc ngo√†i",
                            "Ch·ªâ kinh t·∫ø nh√† n∆∞·ªõc",
                            "Ch·ªâ kinh t·∫ø t∆∞ nh√¢n",
                            "Kinh t·∫ø nh√† n∆∞·ªõc v√† kinh t·∫ø t∆∞ nh√¢n",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Vai tr√≤ c·ªßa kinh t·∫ø nh√† n∆∞·ªõc trong n·ªÅn kinh t·∫ø Vi·ªát Nam?",
                        options: [
                            "ƒê·ªôc quy·ªÅn ho√†n to√†n",
                            "Vai tr√≤ ch·ªß ƒë·∫°o, gi·ªØ vai tr√≤ ƒë·ªãnh h∆∞·ªõng",
                            "Kh√¥ng c√≥ vai tr√≤",
                            "Vai tr√≤ b·ªï sung",
                        ],
                        answer: 1,
                    },
                    {
                        q: "M·ª•c ti√™u ph√°t tri·ªÉn c·ªßa kinh t·∫ø th·ªã tr∆∞·ªùng ƒë·ªãnh h∆∞·ªõng x√£ h·ªôi ch·ªß nghƒ©a l√† g√¨?",
                        options: [
                            "T·ªëi ƒëa h√≥a l·ª£i nhu·∫≠n",
                            "D√¢n gi√†u, n∆∞·ªõc m·∫°nh, d√¢n ch·ªß, c√¥ng b·∫±ng, vƒÉn minh",
                            "Ch·ªâ tƒÉng tr∆∞·ªüng kinh t·∫ø",
                            "Ch·ªâ c√¥ng b·∫±ng x√£ h·ªôi",
                        ],
                        answer: 1,
                    },
                    {
                        q: "Quan h·ªá ph√¢n ph·ªëi trong n·ªÅn kinh t·∫ø th·ªã tr∆∞·ªùng ƒë·ªãnh h∆∞·ªõng x√£ h·ªôi ch·ªß nghƒ©a?",
                        options: [
                            "B√¨nh qu√¢n tuy·ªát ƒë·ªëi",
                            "Theo lao ƒë·ªông v√† hi·ªáu qu·∫£ kinh doanh",
                            "Ch·ªâ theo lao ƒë·ªông",
                            "Ch·ªâ theo v·ªën",
                        ],
                        answer: 1,
                    },
                    {
                        q: "C√°c ch√≠nh s√°ch x√£ h·ªôi trong kinh t·∫ø th·ªã tr∆∞·ªùng ƒë·ªãnh h∆∞·ªõng x√£ h·ªôi ch·ªß nghƒ©a?",
                        options: [
                            "B·∫£o ƒë·∫£m an sinh x√£ h·ªôi, gi·∫£m ngh√®o, ph√°t tri·ªÉn gi√°o d·ª•c-y t·∫ø",
                            "Kh√¥ng c·∫ßn ch√≠nh s√°ch x√£ h·ªôi",
                            "Ch·ªâ lo ph√°t tri·ªÉn kinh t·∫ø",
                            "Ch·ªâ gi·∫£m ngh√®o",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Vai tr√≤ c·ªßa nh√† n∆∞·ªõc trong kinh t·∫ø th·ªã tr∆∞·ªùng ƒë·ªãnh h∆∞·ªõng x√£ h·ªôi ch·ªß nghƒ©a?",
                        options: [
                            "Kh√¥ng can thi·ªáp",
                            "ƒê·ªãnh h∆∞·ªõng, ƒëi·ªÅu ti·∫øt v√† qu·∫£n l√Ω vƒ© m√¥",
                            "Qu·∫£n l√Ω vi m√¥ tr·ª±c ti·∫øp",
                            "Ch·ªâ thu thu·∫ø",
                        ],
                        answer: 1,
                    },
                    {
                        q: "ƒê·ªïi m·ªõi kinh t·∫ø ·ªü Vi·ªát Nam b·∫Øt ƒë·∫ßu t·ª´ nƒÉm n√†o?",
                        options: ["1975", "1986", "1990", "1995"],
                        answer: 1,
                    },
                    {
                        q: "N·ªôi dung c∆° b·∫£n c·ªßa ƒë·ªïi m·ªõi kinh t·∫ø ·ªü Vi·ªát Nam?",
                        options: [
                            "Chuy·ªÉn t·ª´ kinh t·∫ø k·∫ø ho·∫°ch h√≥a t·∫≠p trung sang kinh t·∫ø th·ªã tr∆∞·ªùng ƒë·ªãnh h∆∞·ªõng x√£ h·ªôi ch·ªß nghƒ©a",
                            "Ch·ªâ t∆∞ nh√¢n h√≥a",
                            "Ch·ªâ ph√°t tri·ªÉn c√¥ng nghi·ªáp",
                            "Ch·ªâ m·ªü c·ª≠a kinh t·∫ø",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Th√†nh t·ª±u c∆° b·∫£n c·ªßa ƒë·ªïi m·ªõi kinh t·∫ø ·ªü Vi·ªát Nam?",
                        options: [
                            "TƒÉng tr∆∞·ªüng kinh t·∫ø cao v√† b·ªÅn v·ªØng, n√¢ng cao ƒë·ªùi s·ªëng nh√¢n d√¢n",
                            "Ch·ªâ tƒÉng tr∆∞·ªüng kinh t·∫ø",
                            "Ch·ªâ c·∫£i thi·ªán ƒë·ªùi s·ªëng",
                            "Kh√¥ng c√≥ th√†nh t·ª±u ƒë√°ng k·ªÉ",
                        ],
                        answer: 0,
                    },
                ],
                6: [
                    // Ch∆∞∆°ng VI: C√¥ng nghi·ªáp h√≥a, hi·ªán ƒë·∫°i h√≥a v√† h·ªôi nh·∫≠p kinh t·∫ø qu·ªëc t·∫ø c·ªßa Vi·ªát Nam
                    {
                        q: "M·ª•c ti√™u c·ªßa c√¥ng nghi·ªáp h√≥a, hi·ªán ƒë·∫°i h√≥a ·ªü Vi·ªát Nam l√† g√¨?",
                        options: [
                            "Chuy·ªÉn ƒë·ªïi t·ª´ n∆∞·ªõc n√¥ng nghi·ªáp sang n∆∞·ªõc c√¥ng nghi·ªáp hi·ªán ƒë·∫°i",
                            "Ch·ªâ ph√°t tri·ªÉn c√¥ng nghi·ªáp",
                            "Ch·ªâ hi·ªán ƒë·∫°i h√≥a n√¥ng nghi·ªáp",
                            "Ch·ªâ ph√°t tri·ªÉn d·ªãch v·ª•",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Con ƒë∆∞·ªùng c√¥ng nghi·ªáp h√≥a c·ªßa Vi·ªát Nam c√≥ ƒë·∫∑c ƒëi·ªÉm g√¨?",
                        options: [
                            "C√¥ng nghi·ªáp h√≥a g·∫Øn v·ªõi hi·ªán ƒë·∫°i h√≥a",
                            "Ch·ªâ c√¥ng nghi·ªáp h√≥a",
                            "Ch·ªâ hi·ªán ƒë·∫°i h√≥a",
                            "Kh√¥ng c√≥ ƒë·∫∑c ƒëi·ªÉm ri√™ng",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Vai tr√≤ c·ªßa khoa h·ªçc c√¥ng ngh·ªá trong c√¥ng nghi·ªáp h√≥a, hi·ªán ƒë·∫°i h√≥a?",
                        options: [
                            "ƒê·ªông l·ª±c quan tr·ªçng",
                            "Kh√¥ng quan tr·ªçng",
                            "Ch·ªâ h·ªó tr·ª£",
                            "Vai tr√≤ th·ª© y·∫øu",
                        ],
                        answer: 0,
                    },
                    {
                        q: "H·ªôi nh·∫≠p kinh t·∫ø qu·ªëc t·∫ø c·ªßa Vi·ªát Nam c√≥ ƒë·∫∑c ƒëi·ªÉm g√¨?",
                        options: [
                            "Ch·ªß ƒë·ªông, t√≠ch c·ª±c, to√†n di·ªán v√† c√≥ ch·ªçn l·ªçc",
                            "Th·ª• ƒë·ªông",
                            "Ch·ªâ xu·∫•t kh·∫©u",
                            "Ch·ªâ nh·∫≠p kh·∫©u",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Vi·ªát Nam gia nh·∫≠p WTO v√†o nƒÉm n√†o?",
                        options: ["2005", "2007", "2008", "2010"],
                        answer: 1,
                    },
                    {
                        q: "L·ª£i √≠ch c·ªßa h·ªôi nh·∫≠p kinh t·∫ø qu·ªëc t·∫ø ƒë·ªëi v·ªõi Vi·ªát Nam?",
                        options: [
                            "M·ªü r·ªông th·ªã tr∆∞·ªùng, thu h√∫t ƒë·∫ßu t∆∞, chuy·ªÉn giao c√¥ng ngh·ªá",
                            "Ch·ªâ xu·∫•t kh·∫©u h√†ng h√≥a",
                            "Ch·ªâ thu h√∫t ƒë·∫ßu t∆∞",
                            "Kh√¥ng c√≥ l·ª£i √≠ch",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Th√°ch th·ª©c c·ªßa h·ªôi nh·∫≠p kinh t·∫ø qu·ªëc t·∫ø ƒë·ªëi v·ªõi Vi·ªát Nam?",
                        options: [
                            "C·∫°nh tranh kh·ªëc li·ªát, ph·ª• thu·ªôc kinh t·∫ø, t√°c ƒë·ªông ti√™u c·ª±c c·ªßa to√†n c·∫ßu h√≥a",
                            "Kh√¥ng c√≥ th√°ch th·ª©c",
                            "Ch·ªâ c√≥ c·∫°nh tranh",
                            "Ch·ªâ c√≥ ph·ª• thu·ªôc",
                        ],
                        answer: 0,
                    },
                    {
                        q: "ƒê·ªãnh h∆∞·ªõng ph√°t tri·ªÉn kinh t·∫ø ƒë·ªëi ngo·∫°i c·ªßa Vi·ªát Nam?",
                        options: [
                            "ƒêa d·∫°ng h√≥a, ƒëa ph∆∞∆°ng h√≥a c√°c quan h·ªá kinh t·∫ø ƒë·ªëi ngo·∫°i",
                            "Ch·ªâ ph·ª• thu·ªôc m·ªôt th·ªã tr∆∞·ªùng",
                            "ƒê√≥ng c·ª≠a kinh t·∫ø",
                            "Ch·ªâ h·ª£p t√°c song ph∆∞∆°ng",
                        ],
                        answer: 0,
                    },
                    {
                        q: "Vai tr√¥ c·ªßa FDI trong ph√°t tri·ªÉn kinh t·∫ø Vi·ªát Nam?",
                        options: [
                            "B·ªï sung v·ªën, chuy·ªÉn giao c√¥ng ngh·ªá, t·∫°o vi·ªác l√†m",
                            "Ch·ªâ b·ªï sung v·ªën",
                            "Ch·ªâ t·∫°o vi·ªác l√†m",
                            "Kh√¥ng c√≥ vai tr√≤",
                        ],
                        answer: 0,
                    },
                    {
                        q: "M√¥ h√¨nh tƒÉng tr∆∞·ªüng kinh t·∫ø m·ªõi c·ªßa Vi·ªát Nam h∆∞·ªõng t·ªõi?",
                        options: [
                            "TƒÉng tr∆∞·ªüng d·ª±a tr√™n nƒÉng su·∫•t, ch·∫•t l∆∞·ª£ng, hi·ªáu qu·∫£ v√† khoa h·ªçc c√¥ng ngh·ªá",
                            "Ch·ªâ tƒÉng tr∆∞·ªüng v·ªÅ quy m√¥",
                            "Ch·ªâ d·ª±a v√†o t√†i nguy√™n thi√™n nhi√™n",
                            "Ch·ªâ d·ª±a v√†o lao ƒë·ªông gi√° r·∫ª",
                        ],
                        answer: 0,
                    },
                ],
            };

            // --- 2. Kh·ªüi t·∫°o & State ---

            // T·∫°o m√™ cung ng·∫´u nhi√™n (s·ª≠ d·ª•ng Depth-First Search)
            function generateMaze(w, h) {
                const grid = Array.from({ length: h }, () => Array(w).fill(1)); // 1 l√† t∆∞·ªùng
                const stack = [];
                let current = { x: 1, y: 1 };
                grid[current.y][current.x] = 0; // 0 l√† ƒë∆∞·ªùng ƒëi
                stack.push(current);

                const getNeighbors = (p) => {
                    const neighbors = [];
                    [
                        [0, 2],
                        [0, -2],
                        [2, 0],
                        [-2, 0],
                    ].forEach(([dx, dy]) => {
                        const nx = p.x + dx,
                            ny = p.y + dy;
                        if (
                            nx > 0 &&
                            nx < w - 1 &&
                            ny > 0 &&
                            ny < h - 1 &&
                            grid[ny][nx] === 1
                        ) {
                            neighbors.push({
                                x: nx,
                                y: ny,
                                wallX: p.x + dx / 2,
                                wallY: p.y + dy / 2,
                            });
                        }
                    });
                    return neighbors;
                };

                while (stack.length > 0) {
                    current = stack[stack.length - 1];
                    const neighbors = getNeighbors(current);

                    if (neighbors.length > 0) {
                        const next =
                            neighbors[
                                Math.floor(Math.random() * neighbors.length)
                            ];
                        grid[next.wallY][next.wallX] = 0; // Ph√° t∆∞·ªùng
                        grid[next.y][next.x] = 0; // M·ªü √¥ m·ªõi
                        stack.push(next);
                    } else {
                        stack.pop();
                    }
                }
                return grid;
            }

            // ƒê·∫∑t s·ª± ki·ªán v√†o m√™ cung
            function placeEvents() {
                gameEvents = [];
                // Event types order is neutral; later we will bias events based on chosenDirection
                const eventTypes = [2, 3, 4, 2, 3, 4, 2, 3, 4, 5]; // 2: H·ªèi, 3: Th∆∞·ªüng, 4: Khi√™n, 5: Tho√°t
                let placedCount = 0;

                while (placedCount < MAX_EVENTS) {
                    const rx = Math.floor(Math.random() * (N - 2)) + 1;
                    const ry = Math.floor(Math.random() * (N - 2)) + 1;

                    // Ch·ªâ ƒë·∫∑t tr√™n ƒë∆∞·ªùng ƒëi (gi√° tr·ªã 0) v√† kh√¥ng ph·∫£i √¥ b·∫Øt ƒë·∫ßu (1, 1)
                    if (
                        maze[ry][rx] === 0 &&
                        (rx !== player.x || ry !== player.y)
                    ) {
                        // Allow direction influence: if chosenDirection is set, bias event types
                        let type = eventTypes[placedCount];
                        if (chosenDirection === "east") {
                            // East: more questions with higher reward
                            if (Math.random() < 0.6) type = 2;
                        } else if (chosenDirection === "west") {
                            // West: slightly more hazards
                            if (Math.random() < 0.5) type = 2;
                        } else if (chosenDirection === "north") {
                            // North: more rewards
                            if (Math.random() < 0.6) type = 3;
                        } else if (chosenDirection === "south") {
                            // South: more walls? we keep normal distribution but bypass is free
                        }
                        maze[ry][rx] = type;

                        // L∆∞u th√¥ng tin s·ª± ki·ªán
                        gameEvents.push({
                            x: rx,
                            y: ry,
                            type: type,
                            // D·ªØ li·ªáu cho ph√≤ng h·ªèi (type 2)
                            isCleared: false,
                            questionsCorrect: 0,
                            questionsCount:
                                Math.floor(
                                    Math.random() *
                                        (QUESTIONS_MAX - QUESTIONS_MIN + 1)
                                ) + QUESTIONS_MIN,
                            // D·ªØ li·ªáu cho ph√≤ng th∆∞·ªüng (type 3)
                            openedTimes: 0,
                        });
                        placedCount++;
                    }
                }
            }

            function initGame() {
                // Lock direction selection
                directionLocked = true;
                updateSidebarForGameplay();

                // Initialize maze-based chapter system
                currentRoomIndex = 1;
                chapterQuestionsCorrect = 0; // Reset chapter progress
                isGameRunning = true;
                player = { x: 1, y: 1, lives: MAX_LIVES, score: 0, shield: 0 };

                // Start with first chapter maze
                const mazeSize = 15;
                maze = generateMaze(mazeSize, mazeSize);
                mazeWidth = mazeSize;
                mazeHeight = mazeSize;

                // Place events in the maze
                placeRoomEvents();
                updateHUD();
                draw();
            }

            function placeRoomEvents() {
                gameEvents = [];

                // Each maze corresponds to a chapter (1-6)
                // Create exactly 10 question events per chapter
                let baseEventTypes = [];

                // Add exactly 10 question events (each contains 1 question)
                for (let i = 0; i < 10; i++) {
                    baseEventTypes.push(2); // question type
                }

                // Add 1-2 reward chests per maze
                const rewardCount =
                    Math.floor(
                        Math.random() *
                            (GAME_CONFIG.MAX_REWARDS_PER_MAZE -
                                GAME_CONFIG.MIN_REWARDS_PER_MAZE +
                                1)
                    ) + GAME_CONFIG.MIN_REWARDS_PER_MAZE;
                for (let i = 0; i < rewardCount; i++) {
                    baseEventTypes.push(3);
                }

                // Add shields
                for (let i = 0; i < GAME_CONFIG.SHIELDS_PER_MAZE; i++) {
                    baseEventTypes.push(4);
                }

                // Add special events for final chapter
                if (currentRoomIndex === 1) {
                    baseEventTypes.push(7); // Boss Mr.Ph√∫c in final chapter
                    baseEventTypes.push(5); // Exit only in final chapter
                }

                // Adjust based on chosen direction (add extra items, not questions)
                if (chosenDirection === "east") {
                    // East gets bonus points per question, no need for extra questions
                } else if (chosenDirection === "north") {
                    // Add one more reward (but still limited)
                    if (rewardCount === 1) baseEventTypes.push(3);
                } else if (chosenDirection === "west") {
                    // Add more shields (for safety)
                    for (let i = 0; i < GAME_CONFIG.EXTRA_SHIELDS_WEST; i++) {
                        baseEventTypes.push(4);
                    }
                } else if (chosenDirection === "south") {
                    // Balanced distribution - add extra shields
                    for (let i = 0; i < GAME_CONFIG.EXTRA_SHIELDS_SOUTH; i++) {
                        baseEventTypes.push(4);
                    }
                }

                let placedCount = 0;
                const maxEvents = Math.min(baseEventTypes.length, 12); // More events per maze

                while (placedCount < maxEvents) {
                    const rx = Math.floor(Math.random() * (N - 2)) + 1;
                    const ry = Math.floor(Math.random() * (N - 2)) + 1;

                    if (
                        maze[ry][rx] === 0 &&
                        (rx !== player.x || ry !== player.y)
                    ) {
                        const type = baseEventTypes[placedCount];
                        maze[ry][rx] = type;

                        gameEvents.push({
                            x: rx,
                            y: ry,
                            type: type,
                            isCleared: false,
                            questionsCorrect: 0,
                            questionsCount: type === 2 ? 1 : 10, // 1 question per question event, 10 for others
                            questionsMin: type === 2 ? 1 : 5, // Need 1 correct for question events
                            chapterIndex: currentRoomIndex, // Link to chapter
                            openedTimes: 0,
                            // For question events, pre-assign a specific question
                            assignedQuestionIndex:
                                type === 2
                                    ? Math.floor(
                                          Math.random() *
                                              (
                                                  questionsByChapter[
                                                      currentRoomIndex
                                                  ] || questionsByChapter[1]
                                              ).length
                                      )
                                    : null,
                            // Retry system tracking
                            questionAttempts: {},
                            shuffledOptions: {},
                            retryingQuestion: false,
                        });
                        placedCount++;
                    }
                }

                // Always add a way to progress to next chapter (if not final)
                if (currentRoomIndex < totalRooms) {
                    addChapterExit();
                }
            }

            // Add a chapter exit portal to progress to next maze - always at corner
            function addChapterExit() {
                // Define corner positions (top-left, top-right, bottom-left, bottom-right)
                const corners = [
                    { x: 1, y: 1 }, // top-left
                    { x: N - 2, y: 1 }, // top-right
                    { x: 1, y: N - 2 }, // bottom-left
                    { x: N - 2, y: N - 2 }, // bottom-right
                ];

                // Try each corner until we find an available spot
                let exitPlaced = false;
                for (let corner of corners) {
                    if (maze[corner.y][corner.x] === 0) {
                        // Place exit at this corner
                        maze[corner.y][corner.x] = 6; // New type for chapter exit

                        gameEvents.push({
                            x: corner.x,
                            y: corner.y,
                            type: 6, // Chapter exit portal
                            isCleared: false,
                            chapterIndex: currentRoomIndex,
                        });
                        exitPlaced = true;
                        break;
                    }
                }

                // If no corner is available, force place at bottom-right corner
                if (!exitPlaced) {
                    const corner = { x: N - 2, y: N - 2 };
                    maze[corner.y][corner.x] = 6;
                    gameEvents.push({
                        x: corner.x,
                        y: corner.y,
                        type: 6,
                        isCleared: false,
                        chapterIndex: currentRoomIndex,
                    });
                }
            }

            function nextChapter() {
                if (currentRoomIndex >= totalRooms) {
                    // Game complete ‚Äî show traditional overlay
                    showOverlayMode("traditional");
                    document.getElementById("overlay-title").textContent =
                        "üéâ CHI·∫æN TH·∫ÆNG! üéâ";
                    document.getElementById("overlay-message").innerHTML =
                        `Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh t·∫•t c·∫£ ${totalRooms} ch∆∞∆°ng Kinh t·∫ø ch√≠nh tr·ªã M√°c-L√™nin!<br><br>` +
                        `ƒêi·ªÉm s·ªë cu·ªëi c√πng: <strong>${player.score}</strong><br>` +
                        `H∆∞·ªõng ƒë√£ ch·ªçn: <strong>${getDirectionName(
                            chosenDirection
                        )}</strong><br><br>` +
                        `B·∫°n ƒë√£ n·∫Øm v·ªØng ki·∫øn th·ª©c t·ª´ T·ªïng quan ƒë·∫øn H·ªôi nh·∫≠p kinh t·∫ø qu·ªëc t·∫ø. C·∫£m ∆°n b·∫°n ƒë√£ h·ªçc t·∫≠p!`;
                    document.querySelector(
                        "#traditional-overlay button"
                    ).textContent = "Ch∆°i l·∫°i";
                    document.querySelector(
                        "#traditional-overlay button"
                    ).onclick = () => restartGame();
                } else {
                    currentRoomIndex++;

                    // Generate new maze for the next chapter
                    const mazeSize = 15;
                    maze = generateMaze(mazeSize, mazeSize);
                    mazeWidth = mazeSize;
                    mazeHeight = mazeSize;

                    // Reset chapter progress
                    chapterQuestionsCorrect = 0;

                    // Place events in the new maze
                    placeRoomEvents();
                    updateHUD();

                    // Reset player position to start of new maze
                    player.x = 1;
                    player.y = 1;

                    draw();

                    const chapterTitles = {
                        1: "Ch∆∞∆°ng I: T·ªïng quan v·ªÅ Kinh t·∫ø Ch√≠nh tr·ªã M√°c-L√™nin",
                        2: "Ch∆∞∆°ng II: H√†ng h√≥a, th·ªã tr∆∞·ªùng v√† vai tr√≤ c·ªßa c√°c ch·ªß th·ªÉ tham gia th·ªã tr∆∞·ªùng",
                        3: "Ch∆∞∆°ng III: Gi√° tr·ªã th·∫∑ng d∆∞ trong n·ªÅn kinh t·∫ø th·ªã tr∆∞·ªùng",
                        4: "Ch∆∞∆°ng IV: C·∫°nh tranh v√† ƒë·ªôc quy·ªÅn trong n·ªÅn kinh t·∫ø th·ªã tr∆∞·ªùng",
                        5: "Ch∆∞∆°ng V: Kinh t·∫ø th·ªã tr∆∞·ªùng ƒë·ªãnh h∆∞·ªõng x√£ h·ªôi ch·ªß nghƒ©a v√† c√°c quan h·ªá l·ª£i √≠ch kinh t·∫ø ·ªü Vi·ªát Nam",
                        6: "Ch∆∞∆°ng VI: C√¥ng nghi·ªáp h√≥a, hi·ªán ƒë·∫°i h√≥a v√† h·ªôi nh·∫≠p kinh t·∫ø qu·ªëc t·∫ø c·ªßa Vi·ªát Nam",
                    };

                    openModalMsg(
                        `${chapterTitles[currentRoomIndex]}`,
                        `Ch√†o m·ª´ng ƒë·∫øn v·ªõi Ch∆∞∆°ng ${currentRoomIndex}! H√£y kh√°m ph√° m√™ cung v√† t√¨m 10 √¥ c√¢u h·ªèi. M·ªói √¥ ch·ª©a 1 c√¢u h·ªèi. B·∫°n c·∫ßn tr·∫£ l·ªùi ƒë√∫ng t·ªëi thi·ªÉu 5/10 c√¢u ƒë·ªÉ m·ªü c·ªïng ch∆∞∆°ng ti·∫øp theo!`
                    );
                }
            }

            function getDirectionName(dir) {
                const names = {
                    east: "ƒê√¥ng",
                    west: "T√¢y",
                    north: "B·∫Øc",
                    south: "Nam",
                };
                return names[dir] || dir;
            }

            function updateSidebarForGameplay() {
                // Hide direction selection buttons
                document.getElementById("direction-buttons").style.display =
                    "none";
                document.getElementById("direction-locked").style.display =
                    "block";
                document.getElementById("panel-title").textContent =
                    "Tr·∫°ng th√°i game";
                document.getElementById("locked-direction").textContent =
                    getDirectionName(chosenDirection);

                // Update space hint for gameplay
                document.getElementById("space-hint").textContent =
                    "Space: b·∫≠t/t·∫Øt v∆∞·ª£t t∆∞·ªùng. T√¨m l·ªëi tho√°t ƒë·ªÉ sang ph√≤ng ti·∫øp theo.";
            }

            // --- 3. Logic Giao di·ªán (Draw, HUD, Modals) ---

            // C·∫≠p nh·∫≠t tr·∫°ng th√°i ng∆∞·ªùi ch∆°i l√™n HUD
            function updateHUD() {
                document.getElementById("lives").textContent = player.lives;
                document.getElementById("score").textContent = player.score;
                document.getElementById("shield-count").textContent =
                    player.shield;
                document.getElementById(
                    "room"
                ).textContent = `Ch∆∞∆°ng ${currentRoomIndex} / ${totalRooms} (${chapterQuestionsCorrect}/10)`;
            }

            // Hi·ªÉn th·ªã modal th√¥ng b√°o chung
            function openModalMsg(
                title,
                message,
                options = [{ text: "ƒê√≥ng", action: "closeModal" }]
            ) {
                const modal = document.getElementById("modal-event");
                document.getElementById("modal-title").textContent = title;
                document.getElementById("modal-message").innerHTML = message;

                const optionsBox = document.getElementById("modal-options");
                optionsBox.innerHTML = "";
                options.forEach((opt) => {
                    const button = document.createElement("button");
                    button.textContent = opt.text;
                    // If action is a string, call the named function on window (e.g. "closeModal").
                    // Using new Function(opt.action) would only evaluate the expression but not call it.
                    if (typeof opt.action === "string") {
                        button.onclick = () => {
                            if (typeof window[opt.action] === "function") {
                                window[opt.action]();
                            }
                        };
                    } else {
                        button.onclick = opt.action;
                    }
                    optionsBox.appendChild(button);
                });
                modal.showModal();
            }

            // ƒê√≥ng modal th√¥ng b√°o chung
            function closeModal() {
                document.getElementById("modal-event").close();
            }

            // Hi·ªÉn th·ªã/·∫©n overlay (M√†n h√¨nh kh·ªüi ƒë·ªông/k·∫øt th√∫c)
            function showOverlay(
                title,
                message,
                buttonText = "B·∫Øt ƒê·∫ßu L·∫°i",
                action = "restartGame"
            ) {
                document.getElementById("overlay-title").textContent = title;
                document.getElementById("overlay-message").innerHTML = message;
                const button = document.querySelector("#game-overlay button");
                button.textContent = buttonText;
                // If action is a string, call the named function on window (e.g. "restartGame").
                if (typeof action === "string") {
                    button.onclick = () => {
                        if (typeof window[action] === "function") {
                            window[action]();
                        }
                    };
                } else {
                    button.onclick = action;
                }
                document.getElementById("game-overlay").style.display = "flex";
                isGameRunning = false;
            }

            // V·∫Ω m√™ cung v√† ng∆∞·ªùi ch∆°i
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // If player is inside a mini-room, draw that room instead
                if (inRoom && currentRoom) {
                    const rMaze = currentRoom.maze;
                    const rN = rMaze.length;
                    const rCell = Math.min(
                        CELL_SIZE,
                        Math.floor(canvas.width / rN)
                    );
                    // center room on canvas
                    const offsetX = (canvas.width - rN * rCell) / 2;
                    const offsetY = (canvas.height - rN * rCell) / 2;

                    for (let y = 0; y < rN; y++) {
                        for (let x = 0; x < rN; x++) {
                            const val = rMaze[y][x];
                            const cx = offsetX + x * rCell;
                            const cy = offsetY + y * rCell;
                            if (val === 1) {
                                ctx.fillStyle = "#1e2a4b";
                                ctx.fillRect(cx, cy, rCell, rCell);
                            } else {
                                ctx.fillStyle = "#0b0c12";
                                ctx.fillRect(cx, cy, rCell, rCell);
                            }
                            if (
                                x === currentRoom.exitX &&
                                y === currentRoom.exitY
                            ) {
                                ctx.fillStyle = "#ef4444";
                                ctx.fillRect(
                                    cx + rCell * 0.2,
                                    cy + rCell * 0.2,
                                    rCell * 0.6,
                                    rCell * 0.6
                                );
                            }
                        }
                    }

                    // draw room player
                    ctx.beginPath();
                    ctx.arc(
                        offsetX + roomPlayer.x * rCell + rCell / 2,
                        offsetY + roomPlayer.y * rCell + rCell / 2,
                        rCell / 3,
                        0,
                        Math.PI * 2
                    );
                    ctx.fillStyle = "#fef08a";
                    ctx.fill();
                    return;
                }

                // Draw main maze
                for (let y = 0; y < N; y++) {
                    for (let x = 0; x < N; x++) {
                        const cellValue = maze[y][x];
                        const cellX = x * CELL_SIZE;
                        const cellY = y * CELL_SIZE;

                        // V·∫Ω t∆∞·ªùng
                        if (cellValue === 1) {
                            ctx.fillStyle = "#1e2a4b";
                            ctx.fillRect(cellX, cellY, CELL_SIZE, CELL_SIZE);
                        } else {
                            // V·∫Ω ƒë∆∞·ªùng ƒëi
                            ctx.fillStyle = "#0b0c12";
                            ctx.fillRect(cellX, cellY, CELL_SIZE, CELL_SIZE);
                        }

                        // V·∫Ω s·ª± ki·ªán (s·ª≠ d·ª•ng Icon)
                        if (cellValue >= 2 && cellValue <= 7) {
                            const eventInfo = iconData[cellValue];
                            if (eventInfo) {
                                // V·∫Ω n·ªÅn m√†u cho √¥ s·ª± ki·ªán
                                ctx.fillStyle = eventInfo.color + "22"; // Th√™m ƒë·ªô trong su·ªët
                                ctx.fillRect(
                                    cellX,
                                    cellY,
                                    CELL_SIZE,
                                    CELL_SIZE
                                );

                                // Ch√®n SVG Icon (ph·ª©c t·∫°p h∆°n tr√™n canvas)
                                // C√°ch ƒë∆°n gi·∫£n l√† v·∫Ω m·ªôt h√¨nh tr√≤n m√†u ƒë·∫°i di·ªán
                                ctx.beginPath();
                                ctx.arc(
                                    cellX + CELL_SIZE / 2,
                                    cellY + CELL_SIZE / 2,
                                    CELL_SIZE / 3,
                                    0,
                                    Math.PI * 2
                                );
                                ctx.fillStyle = eventInfo.color;
                                ctx.fill();

                                // N·∫øu ƒë√£ t·∫£i ·∫£nh SVG th√†nh c√¥ng, v·∫Ω ·∫£nh (y√™u c·∫ßu loadIcons() tr∆∞·ªõc)
                                const img = iconImages[cellValue];
                                if (img && img.complete) {
                                    const size = CELL_SIZE * 0.7;
                                    ctx.drawImage(
                                        img,
                                        cellX + (CELL_SIZE - size) / 2,
                                        cellY + (CELL_SIZE - size) / 2,
                                        size,
                                        size
                                    );
                                } else {
                                    // Fallback: s·ª≠ d·ª•ng text ƒë∆°n gi·∫£n n·∫øu SVG kh√¥ng t·∫£i ƒë∆∞·ª£c
                                    const text = {
                                        2: "?",
                                        3: "R",
                                        4: "S",
                                        5: "E",
                                        6: "‚≠ê",
                                    }[cellValue];
                                    ctx.fillStyle = "#fff";
                                    ctx.font = "bold 20px Arial";
                                    ctx.textAlign = "center";
                                    ctx.textBaseline = "middle";
                                    ctx.fillText(
                                        text,
                                        cellX + CELL_SIZE / 2,
                                        cellY + CELL_SIZE / 2
                                    );
                                }
                            }
                        }
                    }
                }

                // V·∫Ω ng∆∞·ªùi ch∆°i
                ctx.beginPath();
                ctx.arc(
                    player.x * CELL_SIZE + CELL_SIZE / 2,
                    player.y * CELL_SIZE + CELL_SIZE / 2,
                    CELL_SIZE / 3,
                    0,
                    Math.PI * 2
                );
                ctx.fillStyle = "#fef08a"; // M√†u v√†ng cho nh√¢n v·∫≠t
                ctx.fill();

                // V·∫Ω khi√™n n·∫øu c√≥
                if (player.shield > 0) {
                    ctx.strokeStyle = "#60a5fa";
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }

            // X·ª≠ l√Ω khi m·∫•t m·∫°ng
            function loseLife(reason) {
                player.lives--;
                updateHUD();
                if (player.lives <= 0) {
                    showOverlay(
                        "Game Over",
                        `B·∫°n ƒë√£ h·∫øt m·∫°ng! L√Ω do cu·ªëi c√πng: ${reason}`,
                        "Th·ª≠ l·∫°i",
                        "restartGame"
                    );
                } else {
                    openModalMsg(
                        "B·ªã Tr·ª´ M·∫°ng!",
                        `M·∫•t m·ªôt m·∫°ng. ${reason}. M·∫°ng c√≤n l·∫°i: ${player.lives}`
                    );
                }
            }

            function restartGame() {
                document.getElementById("game-overlay").style.display = "none";
                initGame();
            }

            // Start game (check chosen direction first)
            function startGame() {
                if (!chosenDirection) {
                    openModalMsg(
                        "Ch∆∞a ch·ªçn h∆∞·ªõng",
                        "Vui l√≤ng ch·ªçn 1 h∆∞·ªõng ·ªü thanh b√™n ph·∫£i tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu."
                    );
                    return;
                }
                document.getElementById("game-overlay").style.display = "none";
                initGame();
            }

            // Enter a mini-room (a small maze with an exit)
            function enterRoom(event) {
                if (inRoom) return;
                inRoom = true;
                const roomSize = event.type === 5 ? 13 : 9; // boss rooms are larger
                const rMaze = generateMaze(roomSize, roomSize);
                // find an exit cell randomly on a path
                let exitX = 1,
                    exitY = 1;
                for (let i = 0; i < 200; i++) {
                    const rx = Math.floor(Math.random() * (roomSize - 2)) + 1;
                    const ry = Math.floor(Math.random() * (roomSize - 2)) + 1;
                    if (rMaze[ry][rx] === 0 && (rx !== 1 || ry !== 1)) {
                        exitX = rx;
                        exitY = ry;
                        break;
                    }
                }
                currentRoom = {
                    maze: rMaze,
                    exitX,
                    exitY,
                    type: event.type,
                    eventRef: event,
                };
                roomPlayer = { x: 1, y: 1 };
                openModalMsg(
                    "V√†o ph√≤ng",
                    "B·∫°n ƒë√£ v√†o 1 m√™ cung nh·ªè ‚Äî t√¨m l·ªëi ra (√¥ ƒë·ªè) ƒë·ªÉ ho√†n th√†nh ph√≤ng.",
                    [
                        {
                            text: "B·∫Øt ƒë·∫ßu",
                            action: () => {
                                closeModal();
                                draw();
                            },
                        },
                    ]
                );
                draw();
            }

            // --- 4. Logic T∆∞∆°ng t√°c (Di chuy·ªÉn, V∆∞·ª£t t∆∞·ªùng, D·∫´m l√™n √¥) ---

            // X·ª≠ l√Ω khi ng∆∞·ªùi ch∆°i b∆∞·ªõc v√†o m·ªôt √¥
            function stepOn(x, y) {
                const cellValue = maze[y][x];
                if (cellValue === 0) return; // ƒê∆∞·ªùng ƒëi tr·ªëng

                // T√¨m th√¥ng tin s·ª± ki·ªán
                const event = gameEvents.find((e) => e.x === x && e.y === y);

                if (event && !event.isCleared) {
                    switch (cellValue) {
                        case 2: // Ph√≤ng h·ªèi
                            handleQuestionRoom(event);
                            break;
                        case 3: // Ph√≤ng th∆∞·ªüng
                            handleRewardRoom(event);
                            break;
                        case 4: // L·∫•y khi√™n
                            handleShieldPickup(event);
                            break;
                        case 6: // C·ªïng chuy·ªÉn ch∆∞∆°ng
                            handleChapterExit(event);
                            break;
                        case 7: // Boss Fight - Mr.Ph√∫c
                            handleBossFight(event);
                            break;
                        case 5: // L·ªëi tho√°t cu·ªëi game
                            event.isCleared = true;
                            maze[event.y][event.x] = 0;
                            // Final victory
                            showOverlayMode("traditional");
                            document.getElementById(
                                "overlay-title"
                            ).textContent = "üéâ CHI·∫æN TH·∫ÆNG! üéâ";
                            document.getElementById(
                                "overlay-message"
                            ).innerHTML =
                                `Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh t·∫•t c·∫£ ${totalRooms} ch∆∞∆°ng Kinh t·∫ø ch√≠nh tr·ªã M√°c-L√™nin!<br><br>` +
                                `ƒêi·ªÉm s·ªë cu·ªëi c√πng: <strong>${player.score}</strong><br>` +
                                `H∆∞·ªõng ƒë√£ ch·ªçn: <strong>${getDirectionName(
                                    chosenDirection
                                )}</strong><br><br>` +
                                `B·∫°n ƒë√£ n·∫Øm v·ªØng ki·∫øn th·ª©c t·ª´ T·ªïng quan ƒë·∫øn H·ªôi nh·∫≠p kinh t·∫ø qu·ªëc t·∫ø. C·∫£m ∆°n b·∫°n ƒë√£ h·ªçc t·∫≠p!`;
                            document.querySelector(
                                "#traditional-overlay button"
                            ).textContent = "Ch∆°i l·∫°i";
                            document.querySelector(
                                "#traditional-overlay button"
                            ).onclick = () => restartGame();
                            break;
                        case 6: // C·ªïng chuy·ªÉn ch∆∞∆°ng
                            if (chapterQuestionsCorrect >= 5) {
                                event.isCleared = true;
                                maze[event.y][event.x] = 0;
                                openModalMsg(
                                    "Ho√†n th√†nh ch∆∞∆°ng!",
                                    `üéâ Xu·∫•t s·∫Øc! B·∫°n ƒë√£ tr·∫£ l·ªùi ƒë√∫ng ${chapterQuestionsCorrect}/10 c√¢u h·ªèi trong Ch∆∞∆°ng ${currentRoomIndex}/${totalRooms}. Chu·∫©n b·ªã chuy·ªÉn sang m√™ cung ch∆∞∆°ng ti·∫øp theo!`,
                                    [
                                        {
                                            text: "Sang ch∆∞∆°ng ti·∫øp theo",
                                            action: () => {
                                                closeModal();
                                                nextChapter();
                                            },
                                        },
                                    ]
                                );
                            } else {
                                openModalMsg(
                                    "Ch∆∞a ƒë·ªß ƒëi·ªÅu ki·ªán!",
                                    `B·∫°n c·∫ßn tr·∫£ l·ªùi ƒë√∫ng √≠t nh·∫•t 5/10 c√¢u h·ªèi ƒë·ªÉ m·ªü c·ªïng ch∆∞∆°ng n√†y. Hi·ªán t·∫°i: ${chapterQuestionsCorrect}/10 c√¢u ƒë√∫ng. H√£y t√¨m th√™m c√°c √¥ c√¢u h·ªèi!`,
                                    [
                                        {
                                            text: "Ti·∫øp t·ª•c kh√°m ph√°",
                                            action: "closeModal",
                                        },
                                    ]
                                );
                            }
                            break;
                    }
                } else if (event && event.isCleared) {
                    // ƒê√£ clear s·ª± ki·ªán
                    openModalMsg(
                        "ƒê√£ ho√†n th√†nh",
                        "B·∫°n ƒë√£ ho√†n th√†nh th·ª≠ th√°ch ·ªü ƒë√¢y r·ªìi. H√£y ti·∫øp t·ª•c kh√°m ph√° m√™ cung!"
                    );
                }
            }

            // C∆° ch·∫ø v∆∞·ª£t t∆∞·ªùng (Wall Bypass) ‚Äî h·ªó tr·ª£ flag v√† h∆∞·ªõng 'south' mi·ªÖn ph√≠
            function tryWallBypass(nx, ny) {
                // If bypassFlag is on, attempt bypass (cost depends on chosen direction)
                if (bypassFlag) {
                    // If South chosen, bypass is free
                    if (chosenDirection === "south") {
                        maze[ny][nx] = 0;
                        player.x = nx;
                        player.y = ny;
                        bypassFlag = false; // auto-disable after use
                        document.getElementById(
                            "side-notes"
                        ).textContent = `Bypass: OFF`;
                        draw();
                        stepOn(nx, ny);
                        return;
                    }

                    // Otherwise require points
                    if (player.score >= WALL_BYPASS_COST) {
                        player.score -= WALL_BYPASS_COST;
                        maze[ny][nx] = 0;
                        player.x = nx;
                        player.y = ny;
                        bypassFlag = false;
                        document.getElementById(
                            "side-notes"
                        ).textContent = `Bypass: OFF`;
                        updateHUD();
                        draw();
                        stepOn(nx, ny);
                        return;
                    } else {
                        openModalMsg(
                            "Kh√¥ng ƒë·ªß ƒëi·ªÉm!",
                            `B·∫°n c·∫ßn **${WALL_BYPASS_COST} ƒëi·ªÉm** ƒë·ªÉ v∆∞·ª£t t∆∞·ªùng khi ch∆∞a ch·ªçn Nam mi·ªÖn ph√≠.`
                        );
                        bypassFlag = false;
                        document.getElementById(
                            "side-notes"
                        ).textContent = `Bypass: OFF`;
                        return;
                    }
                }

                // If bypassFlag not on, do nothing - just block the movement (no modal)
            }

            /* Movement Handler */
            const dirs = {
                w: [0, -1],
                a: [-1, 0],
                s: [0, 1],
                d: [1, 0],
                ArrowUp: [0, -1],
                ArrowLeft: [-1, 0],
                ArrowDown: [0, 1],
                ArrowRight: [1, 0],
            };
            window.addEventListener("keydown", (e) => {
                // Handle direction selection mode
                if (introMode === "direction" && !isGameRunning) {
                    const d = dirs[e.key];
                    if (d) {
                        e.preventDefault();
                        const nx = Math.max(
                            0,
                            Math.min(2, selectorPlayer.x + d[0])
                        );
                        const ny = Math.max(
                            0,
                            Math.min(2, selectorPlayer.y + d[1])
                        );
                        selectorPlayer.x = nx;
                        selectorPlayer.y = ny;
                        updateDirectionSelector();
                        return;
                    }
                    if (e.code === "Space" && chosenDirection) {
                        e.preventDefault();
                        // Confirm direction selection and start game
                        document.getElementById("game-overlay").style.display =
                            "none";
                        introMode = "done";
                        initGame();
                        return;
                    }
                    return;
                }

                // Toggle bypass flag with Space anytime during running
                if (e.code === "Space" && isGameRunning) {
                    bypassFlag = !bypassFlag;
                    document.getElementById("side-notes").textContent =
                        bypassFlag ? `Bypass: ON` : `Bypass: OFF`;
                    e.preventDefault();
                    return;
                }

                const d = dirs[e.key];
                if (!d || !isGameRunning) return;
                e.preventDefault();

                // If inside a mini-room, move the roomPlayer instead
                if (inRoom && currentRoom) {
                    const nx = roomPlayer.x + d[0] * SPEED;
                    const ny = roomPlayer.y + d[1] * SPEED;
                    const rMaze = currentRoom.maze;
                    if (
                        nx < 0 ||
                        nx >= rMaze.length ||
                        ny < 0 ||
                        ny >= rMaze.length
                    )
                        return;
                    if (rMaze[ny][nx] === 0) {
                        roomPlayer.x = nx;
                        roomPlayer.y = ny;
                        draw();
                        // Check exit
                        if (
                            nx === currentRoom.exitX &&
                            ny === currentRoom.exitY
                        ) {
                            // resolve room
                            const ev = currentRoom.eventRef;
                            // close room and apply effects based on room type
                            inRoom = false;
                            // After exiting the room, return player to original event cell
                            draw();
                            // Resolve the event now (use original handlers)
                            if (currentRoom.type === 2) {
                                handleQuestionRoom(ev);
                            } else if (currentRoom.type === 3) {
                                handleRewardRoom(ev);
                            } else if (currentRoom.type === 4) {
                                handleShieldPickup(ev);
                            } else if (currentRoom.type === 5) {
                                // Boss/Exit room - reward/finish
                                showOverlay(
                                    "Chi·∫øn Th·∫Øng!",
                                    `B·∫°n ƒë√£ v∆∞·ª£t ph√≤ng boss v·ªõi ${player.score} ƒëi·ªÉm!`,
                                    "Ch∆°i l·∫°i",
                                    "restartGame"
                                );
                            }
                            currentRoom = null;
                            roomPlayer = null;
                        }
                    }
                    return;
                }

                const nx = player.x + d[0] * SPEED;
                const ny = player.y + d[1] * SPEED;

                // Ki·ªÉm tra gi·ªõi h·∫°n b·∫£n ƒë·ªì
                if (nx < 0 || nx >= N || ny < 0 || ny >= N) return;

                // If the cell is a path (0) or an event (2-7) allow moving into it.
                if (
                    maze[ny][nx] === 0 ||
                    (maze[ny][nx] >= 2 && maze[ny][nx] <= 7)
                ) {
                    player.x = nx;
                    player.y = ny;
                    draw();
                    // Handle events directly in the maze (no mini-rooms)
                    if (maze[ny][nx] >= 2 && maze[ny][nx] <= 7) {
                        stepOn(nx, ny);
                    }
                } else if (maze[ny][nx] === 1) {
                    // G·∫∑p t∆∞·ªùng
                    tryWallBypass(nx, ny);
                }
            });

            // --- 5. Logic C√¢u h·ªèi ---
            let currentQuestionEvent = null;

            // X·ª≠ l√Ω khi ph√≤ng c√¢u h·ªèi ƒë∆∞·ª£c ho√†n th√†nh
            function handleRoomClear(event) {
                event.isCleared = true;
                maze[event.y][event.x] = 0; // Bi·∫øn th√†nh ƒë∆∞·ªùng ƒëi
                document.getElementById("modal-question").close();
                openModalMsg(
                    "Ph√≤ng ƒê√£ R√µ!",
                    `Ch√∫c m·ª´ng! B·∫°n ƒë√£ tr·∫£ l·ªùi ƒë√∫ng **${
                        event.questionsCorrect
                    }** / **${
                        event.questionsCount
                    }** c√¢u h·ªèi v√† qua ph√≤ng. B·∫°n nh·∫≠n ƒë∆∞·ª£c **+${
                        event.questionsCorrect * 2
                    } ƒëi·ªÉm**!`,
                    [{ text: "Ti·∫øp t·ª•c", action: "closeModal" }]
                );
                player.score += event.questionsCorrect * 2;
                updateHUD();
                draw();
            }

            // Hi·ªÉn th·ªã modal c√¢u h·ªèi
            function handleQuestionRoom(event) {
                if (event.isCleared) return;

                currentQuestionEvent = event;

                // Get chapter-specific questions
                const chapterQuestions =
                    questionsByChapter[event.chapterIndex] ||
                    questionsByChapter[1];

                // Initialize question tracking
                if (!event.currentRetryCount) event.currentRetryCount = 0;
                if (!event.shuffledOptions) event.shuffledOptions = {};

                // For single-question events, use the pre-assigned question
                let q, qOriginalIndex;
                if (event.currentQuestion) {
                    // Continue with the same question for retry
                    q = event.currentQuestion;
                    qOriginalIndex = event.currentQuestionIndex;
                } else {
                    // Use the pre-assigned question for this event
                    qOriginalIndex = event.assignedQuestionIndex;
                    q = chapterQuestions[qOriginalIndex];

                    // Store current question and reset retry count for new question
                    event.currentQuestion = q;
                    event.currentQuestionIndex = qOriginalIndex;
                    event.currentRetryCount = 0;
                }

                // Update modal title with chapter info
                const chapterTitles = {
                    1: "Ch∆∞∆°ng I: T·ªïng quan v·ªÅ Kinh t·∫ø Ch√≠nh tr·ªã M√°c-L√™nin",
                    2: "Ch∆∞∆°ng II: H√†ng h√≥a, th·ªã tr∆∞·ªùng v√† vai tr√≤ c·ªßa c√°c ch·ªß th·ªÉ tham gia th·ªã tr∆∞·ªùng",
                    3: "Ch∆∞∆°ng III: Gi√° tr·ªã th·∫∑ng d∆∞ trong n·ªÅn kinh t·∫ø th·ªã tr∆∞·ªùng",
                    4: "Ch∆∞∆°ng IV: C·∫°nh tranh v√† ƒë·ªôc quy·ªÅn trong n·ªÅn kinh t·∫ø th·ªã tr∆∞·ªùng",
                    5: "Ch∆∞∆°ng V: Kinh t·∫ø th·ªã tr∆∞·ªùng ƒë·ªãnh h∆∞·ªõng x√£ h·ªôi ch·ªß nghƒ©a v√† c√°c quan h·ªá l·ª£i √≠ch kinh t·∫ø ·ªü Vi·ªát Nam",
                    6: "Ch∆∞∆°ng VI: C√¥ng nghi·ªáp h√≥a, hi·ªán ƒë·∫°i h√≥a v√† h·ªôi nh·∫≠p kinh t·∫ø qu·ªëc t·∫ø c·ªßa Vi·ªát Nam",
                };

                document.getElementById("question-title").textContent = `‚ùì ${
                    chapterTitles[event.chapterIndex] ||
                    "C√¢u H·ªèi Kinh T·∫ø Ch√≠nh Tr·ªã"
                }`;

                document.getElementById("q-correct-count").textContent =
                    chapterQuestionsCorrect;
                document.getElementById("q-required-count").textContent = 5;
                document.getElementById(
                    "retry-count"
                ).textContent = `L·∫ßn th·ª≠: ${event.currentRetryCount}`;
                document.getElementById("question-text").textContent = q.q;

                const optsBox = document.getElementById("question-options");
                optsBox.innerHTML = "";

                // Use shuffled options if available (for retries), otherwise create new shuffle
                let optionsShuffled;
                if (event.shuffledOptions[qOriginalIndex]) {
                    // Use existing shuffle for retry (don't shuffle again)
                    optionsShuffled = event.shuffledOptions[qOriginalIndex];
                } else {
                    // First time seeing this question, shuffle and store
                    optionsShuffled = q.options
                        .map((text, index) => ({ text, index }))
                        .sort(() => Math.random() - 0.5);
                    event.shuffledOptions[qOriginalIndex] = optionsShuffled;
                }

                optionsShuffled.forEach((opt) => {
                    const b = document.createElement("button");
                    b.textContent = opt.text;
                    b.onclick = () => {
                        const correct = opt.index === q.answer;

                        if (correct) {
                            // Correct answer - mark this event as completed
                            event.isCleared = true;
                            maze[event.y][event.x] = 0; // Remove from maze
                            chapterQuestionsCorrect++; // Increment chapter progress

                            // Calculate points based on direction and retry count
                            const basePoints =
                                chosenDirection === "east"
                                    ? GAME_CONFIG.EAST_BONUS_POINTS
                                    : GAME_CONFIG.BASE_POINTS;

                            // Get penalty based on retry count (penalty equals currentRetryCount for retry attempts)
                            const retryPenalty = event.currentRetryCount;
                            const actualPoints = Math.max(
                                GAME_CONFIG.MIN_POINTS_PER_QUESTION,
                                basePoints - retryPenalty
                            );

                            player.score += actualPoints;
                            updateHUD();

                            const retryMessage =
                                retryPenalty > 0
                                    ? ` (Tr·ª´ ${retryPenalty} ƒëi·ªÉm do th·ª≠ l·∫°i ${retryPenalty} l·∫ßn)`
                                    : "";

                            // Close question modal and show success message
                            document.getElementById("modal-question").close();

                            // Check if chapter can be completed
                            let statusMessage = `Ti·∫øn tr√¨nh ch∆∞∆°ng: ${chapterQuestionsCorrect}/10 c√¢u ƒë√∫ng`;
                            if (chapterQuestionsCorrect >= 5) {
                                statusMessage += `<br>üéâ <strong>ƒê√£ ƒë·ªß 5 c√¢u ƒë·ªÉ m·ªü c·ªïng ch∆∞∆°ng!</strong>`;
                                // Make chapter exit available if it exists
                                const chapterExit = gameEvents.find(
                                    (e) => e.type === 6
                                );
                                if (chapterExit) {
                                    chapterExit.isAvailable = true;
                                }
                            }

                            openModalMsg(
                                "Ch√≠nh X√°c!",
                                `Tuy·ªát v·ªùi, +${actualPoints} ƒëi·ªÉm!${retryMessage}<br><br>${statusMessage}`,
                                [
                                    {
                                        text: "Ti·∫øp t·ª•c",
                                        action: () => {
                                            closeModal();
                                            draw(); // Redraw to show removed question mark
                                        },
                                    },
                                ]
                            );
                        } else {
                            // Wrong answer - subtract 1 point from reward instead of losing life
                            const pointsLost = 1;
                            player.score = Math.max(
                                0,
                                player.score - pointsLost
                            );
                            updateHUD();

                            event.currentRetryCount++;

                            // Close question modal and show penalty message
                            document.getElementById("modal-question").close();
                            openModalMsg(
                                "Kh√¥ng Ch√≠nh X√°c!",
                                `C√¢u tr·∫£ l·ªùi sai! B·∫°n b·ªã tr·ª´ ${pointsLost} ƒëi·ªÉm. (L·∫ßn th·ª≠ ${event.currentRetryCount})`,
                                [
                                    {
                                        text: "Th·ª≠ l·∫°i",
                                        action: () => {
                                            closeModal();
                                            handleQuestionRoom(event);
                                        },
                                    },
                                ]
                            );
                        }
                    };
                    optsBox.appendChild(b);
                });

                document.getElementById("modal-question").showModal();
            }

            // --- 6. Logic Ph√≤ng th∆∞·ªüng (M·ªõi) ---

            function handleShieldPickup(event) {
                event.isCleared = true;
                maze[event.y][event.x] = 0;
                player.shield++;
                updateHUD();
                openModalMsg(
                    "Nh·∫≠n Khi√™n!",
                    "B·∫°n nh·∫≠n ƒë∆∞·ª£c **1 Khi√™n üõ°Ô∏è**. Khi√™n s·∫Ω b·∫£o v·ªá b·∫°n kh·ªèi b·ªã tr·ª´ ƒëi·ªÉm 1 l·∫ßn khi thua mini game x√∫c x·∫Øc!",
                    [{ text: "Ti·∫øp t·ª•c", action: "closeModal" }]
                );
                draw();
            }

            function handleRewardRoom(event) {
                if (event.openedTimes === 0) {
                    // L·∫ßn 1: Ch·∫Øc ch·∫Øn c√≥ th∆∞·ªüng
                    event.openedTimes++;

                    // Reward sizes can be larger if chosenDirection is north
                    const rewardPool = [
                        {
                            text: "+1 M·∫°ng ‚ù§Ô∏è",
                            action: () => {
                                player.lives++;
                                updateHUD();
                            },
                            points: 0,
                        },
                        {
                            text: "+1 Khi√™n üõ°Ô∏è",
                            action: () => {
                                player.shield++;
                                updateHUD();
                            },
                            points: 0,
                        },
                        {
                            text: "+20 ƒêi·ªÉm ‚≠ê",
                            action: () => {
                                player.score +=
                                    GAME_CONFIG.TREASURE_SMALL_REWARD;
                                updateHUD();
                            },
                            points: 20,
                        },
                    ];

                    // If North chosen, boost chance for points and increase amount
                    if (chosenDirection === "north") {
                        rewardPool.push({
                            text: "+50 ƒêi·ªÉm ‚≠ê (B·∫Øc bonus)",
                            action: () => {
                                player.score += GAME_CONFIG.TREASURE_BIG_REWARD;
                                updateHUD();
                            },
                            points: 50,
                        });
                        // duplicate some rewards to increase chance
                        rewardPool.push(rewardPool[2]);
                    }

                    const reward =
                        rewardPool[
                            Math.floor(Math.random() * rewardPool.length)
                        ];

                    openModalMsg(
                        "Ph·∫ßn Th∆∞·ªüng L·∫ßn 1!",
                        `Ch√∫c m·ª´ng! B·∫°n ƒë√£ nh·∫≠n ƒë∆∞·ª£c: **${reward.text}**.`,
                        [
                            {
                                text: "Ti·∫øp t·ª•c",
                                action: () => {
                                    reward.action();
                                    closeModal();
                                    // Sau khi nh·∫≠n th∆∞·ªüng, c√≥ th·ªÉ ch·ªçn m·ªü r∆∞∆°ng ti·∫øp
                                    handleRewardRoom(event);
                                },
                            },
                        ]
                    );

                    event.isCleared = true; // ƒê√°nh d·∫•u l√† ƒë√£ m·ªü l·∫ßn 1 (d√π ch∆∞a k·∫øt th√∫c)
                    maze[event.y][event.x] = 0; // Bi·∫øn th√†nh ƒë∆∞·ªùng ƒëi ƒë·ªÉ c√≥ th·ªÉ quay l·∫°i
                    draw();
                } else {
                    // L·∫ßn 2 tr·ªü ƒëi: Mini-game Ch·∫µn/L·∫ª
                    openDiceRollModal(event);
                }
            }

            // M·ªü mini-game x√∫c x·∫Øc
            function openDiceRollModal(event) {
                openModalMsg(
                    "Mini-game X√∫c X·∫Øc Ch·∫µn/L·∫ª",
                    `B·∫°n mu·ªën c∆∞·ª£c gi√° tr·ªã x√∫c x·∫Øc l√† **L·ªõn (4, 5, 6)** hay **Nh·ªè (1, 2, 3)**? C∆∞·ª£c **5 ƒëi·ªÉm** ƒë·ªÉ tham gia! ƒêi·ªÉm hi·ªán t·∫°i: ${player.score}`,
                    [
                        {
                            text: "C∆∞·ª£c L·ªõn (4-6)",
                            action: () => checkDiceBet(event, "large"),
                        },
                        {
                            text: "C∆∞·ª£c Nh·ªè (1-3)",
                            action: () => checkDiceBet(event, "small"),
                        },
                        { text: "R·ªùi ƒëi", action: "closeModal" },
                    ]
                );
            }

            // Ki·ªÉm tra k·∫øt qu·∫£ x√∫c x·∫Øc
            function checkDiceBet(event, bet) {
                if (player.score < 5) {
                    openModalMsg(
                        "Kh√¥ng ƒë·ªß ƒëi·ªÉm!",
                        "B·∫°n c·∫ßn √≠t nh·∫•t **5 ƒëi·ªÉm** ƒë·ªÉ tham gia c∆∞·ª£c.",
                        [{ text: "ƒê√≥ng", action: "closeModal" }]
                    );
                    return;
                }

                player.score -= GAME_CONFIG.DICE_BET_COST; // Tr·ª´ ƒëi·ªÉm c∆∞·ª£c
                updateHUD();

                const diceRoll =
                    Math.floor(Math.random() * GAME_CONFIG.DICE_SIDES) + 1;
                event.openedTimes++;

                let result = "";
                let win = false;

                if (
                    (bet === "large" && diceRoll >= 4) ||
                    (bet === "small" && diceRoll <= 3)
                ) {
                    win = true;
                    player.score += GAME_CONFIG.DICE_WIN_REWARD; // Th∆∞·ªüng (5 ƒëi·ªÉm c∆∞·ª£c + 5 ƒëi·ªÉm th·∫Øng)
                    result = `Th·∫Øng! X√∫c x·∫Øc ra ${diceRoll}. B·∫°n nh·∫≠n th√™m **+5 ƒëi·ªÉm** , hi·ªán b·∫°n ƒëang c√≥ **${player.score}** ƒëi·ªÉm.`;
                } else {
                    // Check if player has shield to protect from losing points
                    if (player.shield > 0) {
                        player.shield--; // Use one shield
                        result = `Thua. X√∫c x·∫Øc ra ${diceRoll}. **Khi√™n üõ°Ô∏è ƒë√£ b·∫£o v·ªá b·∫°n!** Kh√¥ng b·ªã tr·ª´ ƒëi·ªÉm th√™m. Khi√™n c√≤n l·∫°i: ${player.shield}`;
                    } else {
                        result = `Thua. X√∫c x·∫Øc ra ${diceRoll}. B·∫°n m·∫•t **5 ƒëi·ªÉm**, hi·ªán b·∫°n ƒëang c√≥ **${player.score}** ƒëi·ªÉm.`;
                    }
                }
                updateHUD();

                openModalMsg(
                    win ? "üéâ Th·∫Øng C∆∞·ª£c!" : "üò• Thua C∆∞·ª£c",
                    `K·∫øt qu·∫£: **${diceRoll}**<div class="dice-display">${
                        win ? "üí∞" : "üíî"
                    }</div>${result}`,
                    [
                        {
                            text: "C∆∞·ª£c ti·∫øp (5 ƒëi·ªÉm)",
                            action: () => {
                                closeModal();
                                openDiceRollModal(event);
                            },
                        },
                        { text: "D·ª´ng l·∫°i", action: "closeModal" },
                    ]
                );
            }

            // Comic panels (Ver4 inspired)
            const introPanels = [
                {
                    art: "üìï",
                    text: 'Th·∫ßy d·∫∑n: "S·∫£n ph·∫©m kh√¥ng r√µ \nM·ª•c ƒë√≠ch - M·ª•c ti√™u - √ù nghƒ©a l√† GAME OVER."',
                },
                {
                    art: "üïµÔ∏è",
                    text: '"C√≥ gi√°n ƒëi·ªáp theo d√µi game c·ªßa c√°c em." \nH√£y ch·ª©ng minh gi√° tr·ªã h·ªçc thu·∫≠t!',
                },
                {
                    art: "üè≠‚ù§Ô∏è",
                    text: "S·ª© m·ªánh: t·∫°o GI√Å TR·ªä TH·∫∂NG D∆Ø \nnh∆∞ng v·∫´n gi·ªØ C√îNG B·∫∞NG X√É H·ªòI.",
                },
                {
                    art: "üß≠",
                    text: "Ch·ªçn h∆∞·ªõng kh·ªüi ƒë·∫ßu: ƒê√¥ng, T√¢y, B·∫Øc, Nam. \nM·ªói h∆∞·ªõng c√≥ ∆∞u th·∫ø ri√™ng trong h√†nh tr√¨nh!",
                },
            ];

            function showOverlayMode(kind = "comic") {
                introMode = kind;
                panelIndex = 0;
                document.getElementById("game-overlay").style.display = "flex";

                if (kind === "comic") {
                    document.getElementById("comic-intro").style.display =
                        "block";
                    document.getElementById(
                        "direction-selection"
                    ).style.display = "none";
                    document.getElementById(
                        "traditional-overlay"
                    ).style.display = "none";
                    typePanel();
                } else if (kind === "direction") {
                    document.getElementById("comic-intro").style.display =
                        "none";
                    document.getElementById(
                        "direction-selection"
                    ).style.display = "block";
                    document.getElementById(
                        "traditional-overlay"
                    ).style.display = "none";
                    selectorPlayer = { x: 1, y: 1 };
                    updateDirectionSelector();
                } else {
                    // traditional
                    document.getElementById("comic-intro").style.display =
                        "none";
                    document.getElementById(
                        "direction-selection"
                    ).style.display = "none";
                    document.getElementById(
                        "traditional-overlay"
                    ).style.display = "block";
                }
            }

            function typePanel() {
                const p = introPanels[panelIndex];
                document.getElementById("art").textContent = p.art;
                document.getElementById("caption").textContent = "";
                let i = 0;
                clearInterval(typingId);
                typingId = setInterval(() => {
                    document.getElementById("caption").textContent =
                        p.text.slice(0, ++i);
                    if (i >= p.text.length) clearInterval(typingId);
                }, 18);
            }

            function updateDirectionSelector() {
                document
                    .querySelectorAll(".dir-zone")
                    .forEach((zone) => zone.classList.remove("active"));

                // Map selector player position to direction zones
                const dirMap = {
                    "1,0": "north",
                    "0,1": "west",
                    "1,1": "center",
                    "2,1": "east",
                    "1,2": "south",
                };

                const key = `${selectorPlayer.x},${selectorPlayer.y}`;
                const targetDir = dirMap[key];
                if (targetDir && targetDir !== "center") {
                    document
                        .querySelector(`.dir-zone.${targetDir}`)
                        .classList.add("active");
                    chosenDirection = targetDir;
                    updateSidebarNotes();
                    updateSidebarButtons(); // Sync sidebar buttons
                } else {
                    chosenDirection = null;
                    document.getElementById("side-notes").textContent =
                        "Di chuy·ªÉn ƒë·ªÉ ch·ªçn h∆∞·ªõng, Space ƒë·ªÉ x√°c nh·∫≠n.";
                    updateSidebarButtons(); // Clear sidebar button selection
                }
            }

            // Update sidebar buttons to match chosen direction
            function updateSidebarButtons() {
                document
                    .querySelectorAll(".direction-btn")
                    .forEach((btn) => btn.classList.remove("selected"));

                if (chosenDirection) {
                    const targetBtn = document.querySelector(
                        `.direction-btn[data-dir="${chosenDirection}"]`
                    );
                    if (targetBtn) {
                        targetBtn.classList.add("selected");
                    }
                }
            }

            // Update WASD selector to match chosen direction
            function updateWASDSelector(direction) {
                const directionToPosition = {
                    north: { x: 1, y: 0 },
                    west: { x: 0, y: 1 },
                    east: { x: 2, y: 1 },
                    south: { x: 1, y: 2 },
                };

                if (direction && directionToPosition[direction]) {
                    selectorPlayer.x = directionToPosition[direction].x;
                    selectorPlayer.y = directionToPosition[direction].y;

                    // Update visual state
                    document
                        .querySelectorAll(".dir-zone")
                        .forEach((zone) => zone.classList.remove("active"));
                    const targetZone = document.querySelector(
                        `.dir-zone.${direction}`
                    );
                    if (targetZone) {
                        targetZone.classList.add("active");
                    }
                }
            }

            function updateSidebarNotes() {
                const notes = {
                    east: "ƒê√¥ng: C√¢u h·ªèi th∆∞·ªüng nhi·ªÅu ƒëi·ªÉm (+15 cho m·ªói c√¢u ƒë√∫ng).",
                    west: "T√¢y: Tr·∫£ l·ªùi sai ch·ªâ b·ªã tr·ª´ 5 ƒëi·ªÉm (kh√¥ng m·∫•t m·∫°ng).",
                    north: "B·∫Øc: Nhi·ªÅu r∆∞∆°ng h∆°n v√† ph·∫ßn th∆∞·ªüng l·ªõn h∆°n.",
                    south: "Nam: V∆∞·ª£t t∆∞·ªùng mi·ªÖn ph√≠ khi b·∫≠t ch·∫ø ƒë·ªô v∆∞·ª£t t∆∞·ªùng (Space).",
                };
                document.getElementById("side-notes").textContent =
                    notes[chosenDirection] || "Ch∆∞a ch·ªçn h∆∞·ªõng.";
            }

            /* Start with comic */
            window.onload = function () {
                loadIcons(); // T·∫£i c√°c icon SVG
                canvas.width = N * CELL_SIZE;
                canvas.height = N * CELL_SIZE;

                // Wire up comic controls
                document.getElementById("next-btn").onclick = () => {
                    if (panelIndex < introPanels.length - 1) {
                        panelIndex++;
                        typePanel();
                    } else {
                        // Move to direction selection
                        showOverlayMode("direction");
                    }
                };

                document.getElementById("skip-btn").onclick = () => {
                    showOverlayMode("direction");
                };

                // Wire up legacy direction buttons in side panel (keep as backup)
                document.querySelectorAll(".direction-btn").forEach((btn) => {
                    btn.addEventListener("click", () => {
                        const selectedDirection = btn.getAttribute("data-dir");

                        // Update chosen direction
                        chosenDirection = selectedDirection;

                        // Update sidebar buttons
                        document
                            .querySelectorAll(".direction-btn")
                            .forEach((b) => b.classList.remove("selected"));
                        btn.classList.add("selected");

                        // Update sidebar notes
                        updateSidebarNotes();

                        // Sync with WASD selector if in direction selection mode
                        if (introMode === "direction") {
                            updateWASDSelector(selectedDirection);
                        }
                    });
                });

                // Initialize side-notes
                document.getElementById("side-notes").textContent =
                    "ƒêang xem intro...";

                // Start with comic intro
                showOverlayMode("comic");
            };

            // Handle chapter exit portal
            function handleChapterExit(event) {
                if (
                    chapterQuestionsCorrect >=
                    GAME_CONFIG.MIN_CORRECT_TO_PROGRESS
                ) {
                    event.isCleared = true;
                    maze[event.y][event.x] = 0;
                    openModalMsg(
                        "üö™ C·ªïng Ch∆∞∆°ng M·ªü!",
                        `üéâ Xu·∫•t s·∫Øc! B·∫°n ƒë√£ tr·∫£ l·ªùi ƒë√∫ng ${chapterQuestionsCorrect}/${GAME_CONFIG.QUESTIONS_PER_CHAPTER} c√¢u h·ªèi trong Ch∆∞∆°ng ${currentRoomIndex}/${totalRooms}. Chu·∫©n b·ªã chuy·ªÉn sang m√™ cung ch∆∞∆°ng ti·∫øp theo!`,
                        [
                            {
                                text: "Sang ch∆∞∆°ng ti·∫øp theo ‚Üí",
                                action: () => {
                                    closeModal();
                                    nextChapter();
                                },
                            },
                        ]
                    );
                } else {
                    openModalMsg(
                        "üö™ C·ªïng Ch∆∞∆°ng ƒê√≥ng",
                        `B·∫°n c·∫ßn tr·∫£ l·ªùi ƒë√∫ng √≠t nh·∫•t ${GAME_CONFIG.MIN_CORRECT_TO_PROGRESS}/${GAME_CONFIG.QUESTIONS_PER_CHAPTER} c√¢u h·ªèi ƒë·ªÉ m·ªü c·ªïng. Hi·ªán t·∫°i: ${chapterQuestionsCorrect}/${GAME_CONFIG.QUESTIONS_PER_CHAPTER}.`,
                        [{ text: "Ti·∫øp t·ª•c kh√°m ph√°", action: "closeModal" }]
                    );
                }
            }

            // Handle Boss Fight - Mr.Ph√∫c
            function handleBossFight(event) {
                if (
                    chapterQuestionsCorrect <
                    GAME_CONFIG.MIN_CORRECT_TO_PROGRESS
                ) {
                    openModalMsg(
                        "‚öîÔ∏è Boss Ch∆∞a Xu·∫•t Hi·ªán",
                        `B·∫°n c·∫ßn tr·∫£ l·ªùi ƒë√∫ng √≠t nh·∫•t ${GAME_CONFIG.MIN_CORRECT_TO_PROGRESS}/${GAME_CONFIG.QUESTIONS_PER_CHAPTER} c√¢u h·ªèi tr∆∞·ªõc khi ƒë·ªëi m·∫∑t v·ªõi Boss Mr.Ph√∫c! Hi·ªán t·∫°i: ${chapterQuestionsCorrect}/${GAME_CONFIG.QUESTIONS_PER_CHAPTER}.`,
                        [{ text: "Ti·∫øp t·ª•c chu·∫©n b·ªã", action: "closeModal" }]
                    );
                    return;
                }

                // Initialize boss fight
                event.bossHealth = event.bossHealth || GAME_CONFIG.BOSS_HEALTH;
                event.playerHealth = event.playerHealth || player.lives * 30; // 30 HP per life

                startBossFight(event);
            }

            // Start Boss Fight Game
            function startBossFight(event) {
                const playerAttack =
                    GAME_CONFIG.PLAYER_ATTACK_BASE +
                    Math.floor(player.score / 10) *
                        GAME_CONFIG.PLAYER_ATTACK_BONUS_PER_10_POINTS;
                const playerHealthDisplay = `${event.playerHealth} HP (${player.lives} m·∫°ng + ${player.shield} khi√™n)`;

                // Initialize battle log if not exists
                if (!event.battleLog) {
                    event.battleLog = [];
                    event.battleLog.push({
                        type: "info",
                        text: "Tr·∫≠n chi·∫øn b·∫Øt ƒë·∫ßu!",
                        calc: `S√°t th∆∞∆°ng Player = ${
                            GAME_CONFIG.PLAYER_ATTACK_BASE
                        } (base) + ${Math.floor(player.score / 10)} √ó ${
                            GAME_CONFIG.PLAYER_ATTACK_BONUS_PER_10_POINTS
                        } (ƒëi·ªÉm) = ${playerAttack}`,
                    });
                }

                const battleLogHtml = event.battleLog
                    .map((entry) => {
                        let className = "battle-log-entry";
                        if (entry.type === "damage")
                            className += " battle-log-damage";
                        else if (entry.type === "heal")
                            className += " battle-log-heal";
                        else if (entry.type === "defense")
                            className += " battle-log-defense";

                        return `<div class="${className}">
                        ${entry.text}
                        ${
                            entry.calc
                                ? `<div class="battle-log-calc">${entry.calc}</div>`
                                : ""
                        }
                    </div>`;
                    })
                    .join("");

                openModalMsg(
                    "‚öîÔ∏è BOSS FIGHT: Mr.Ph√∫c!",
                    `<div class="boss-fight-container">
                        <div class="battle-log">
                            <h3>üìä Battle Log & T√≠nh To√°n</h3>
                            <div id="battle-log-content">${battleLogHtml}</div>
                        </div>
                        <div class="boss-stats">
                            <div style="font-size: 24px; margin-bottom: 15px;">üëë Mr.Ph√∫c</div>
                            <div style="color: #ef4444; font-size: 18px; margin-bottom: 10px;">‚ù§Ô∏è ${
                                event.bossHealth
                            }/${GAME_CONFIG.BOSS_HEALTH} HP</div>
                            <div style="margin: 15px 0; font-size: 16px;">VS</div>
                            <div style="color: #22c55e; font-size: 16px; margin-bottom: 10px;">üíö ${playerHealthDisplay}</div>
                            <div style="color: #3b82f6; font-size: 16px; margin-bottom: 15px;">‚öîÔ∏è S√°t th∆∞∆°ng: ${playerAttack}</div>
                            <div style="font-size: 14px; color: #888;">
                                Boss s√°t th∆∞∆°ng: ${
                                    GAME_CONFIG.BOSS_MIN_DAMAGE
                                }-${GAME_CONFIG.BOSS_MAX_DAMAGE}<br>
                                Ph√≤ng th·ªß gi·∫£m: ~${Math.floor(
                                    (GAME_CONFIG.BOSS_MIN_DAMAGE +
                                        GAME_CONFIG.BOSS_MAX_DAMAGE) /
                                        3
                                )}
                            </div>
                        </div>
                    </div>`,
                    [
                        {
                            text: "‚öîÔ∏è T·∫•n C√¥ng!",
                            action: () => executeAttack(event, playerAttack),
                        },
                        {
                            text: "üõ°Ô∏è Ph√≤ng Th·ªß",
                            action: () => executeDefense(event),
                        },
                        {
                            text: "üí® Ch·∫°y Tr·ªën",
                            action: () => {
                                closeModal();
                                openModalMsg(
                                    "üí® B·∫°n ƒë√£ ch·∫°y tr·ªën!",
                                    "Boss Mr.Ph√∫c v·∫´n ƒëang ch·ªù b·∫°n quay l·∫°i..."
                                );
                            },
                        },
                    ]
                );
            }

            // Execute attack in boss fight
            function executeAttack(event, playerAttack) {
                // Player attacks boss
                const randomMod = Math.floor(Math.random() * 10) - 5; // ¬±5 random
                const damage = playerAttack + randomMod;
                const actualDamage = Math.max(1, damage);
                event.bossHealth -= actualDamage;

                // Add to battle log
                event.battleLog.push({
                    type: "damage",
                    text: `‚öîÔ∏è B·∫°n t·∫•n c√¥ng: ${actualDamage} s√°t th∆∞∆°ng`,
                    calc: `${playerAttack} (base) + ${randomMod} (random) = ${damage} ‚Üí ${actualDamage} (min 1)`,
                });

                let result = `B·∫°n g√¢y ${actualDamage} s√°t th∆∞∆°ng cho Mr.Ph√∫c!`;

                // Check if boss is defeated
                if (event.bossHealth <= 0) {
                    event.isCleared = true;
                    maze[event.y][event.x] = 0;
                    player.score += GAME_CONFIG.BOSS_VICTORY_REWARD;
                    updateHUD();

                    openModalMsg(
                        "üéâ TH·∫ÆNG BOSS!",
                        `Ch√∫c m·ª´ng! B·∫°n ƒë√£ ƒë√°nh b·∫°i Boss Mr.Ph√∫c!<br><br>
                        üèÜ Ph·∫ßn th∆∞·ªüng: +${GAME_CONFIG.BOSS_VICTORY_REWARD} ƒëi·ªÉm<br>
                        üí∞ ƒêi·ªÉm hi·ªán t·∫°i: ${player.score}<br><br>
                        B√¢y gi·ªù b·∫°n c√≥ th·ªÉ t√¨m l·ªëi tho√°t ƒë·ªÉ ho√†n th√†nh game!`,
                        [{ text: "Ti·∫øp t·ª•c", action: "closeModal" }]
                    );
                    return;
                }

                // Boss counter-attacks
                const bossAttack =
                    GAME_CONFIG.BOSS_MIN_DAMAGE +
                    Math.floor(
                        Math.random() *
                            (GAME_CONFIG.BOSS_MAX_DAMAGE -
                                GAME_CONFIG.BOSS_MIN_DAMAGE +
                                1)
                    );

                // Apply damage to player
                let playerDamaged = false;
                if (player.shield > 0) {
                    player.shield--;
                    event.battleLog.push({
                        type: "defense",
                        text: `üõ°Ô∏è Khi√™n ch·∫∑n: ${bossAttack} s√°t th∆∞∆°ng`,
                        calc: `Khi√™n c√≤n l·∫°i: ${player.shield}`,
                    });
                    result += `<br>Mr.Ph√∫c t·∫•n c√¥ng ${bossAttack} s√°t th∆∞∆°ng, nh∆∞ng khi√™n ƒë√£ b·∫£o v·ªá b·∫°n! Khi√™n c√≤n: ${player.shield}`;
                } else {
                    event.playerHealth -= bossAttack;
                    event.battleLog.push({
                        type: "damage",
                        text: `üí• Boss t·∫•n c√¥ng: ${bossAttack} s√°t th∆∞∆°ng`,
                        calc: `${GAME_CONFIG.BOSS_MIN_DAMAGE}-${GAME_CONFIG.BOSS_MAX_DAMAGE} range, rolled ${bossAttack}`,
                    });
                    result += `<br>Mr.Ph√∫c g√¢y ${bossAttack} s√°t th∆∞∆°ng cho b·∫°n!`;
                    playerDamaged = true;

                    // Check if player loses a life
                    if (event.playerHealth <= 0 && player.lives > 1) {
                        player.lives--;
                        event.playerHealth = 30; // Reset health for new life
                        result += `<br>üíÄ B·∫°n m·∫•t 1 m·∫°ng! M·∫°ng c√≤n l·∫°i: ${player.lives}`;
                        updateHUD();
                    } else if (event.playerHealth <= 0 && player.lives <= 1) {
                        // Game over
                        openModalMsg(
                            "üíÄ GAME OVER",
                            "B·∫°n ƒë√£ b·ªã Boss Mr.Ph√∫c ƒë√°nh b·∫°i! Game k·∫øt th√∫c.",
                            [
                                {
                                    text: "Ch∆°i l·∫°i",
                                    action: () => location.reload(),
                                },
                            ]
                        );
                        return;
                    }
                }

                closeModal();
                setTimeout(() => startBossFight(event), 1000);
            }

            // Execute defense in boss fight
            function executeDefense(event) {
                const healAmount = 15;
                const oldHealth = event.playerHealth;
                event.playerHealth = Math.min(
                    player.lives * 30,
                    event.playerHealth + healAmount
                );
                const actualHeal = event.playerHealth - oldHealth;

                // Add healing to battle log
                event.battleLog.push({
                    type: "heal",
                    text: `üíö Ph√≤ng th·ªß h·ªìi: +${actualHeal} HP`,
                    calc: `${oldHealth} + ${healAmount} = ${
                        oldHealth + healAmount
                    } ‚Üí ${event.playerHealth} (max: ${player.lives * 30})`,
                });

                // Boss still attacks but with reduced damage
                const bossAttack = Math.floor(
                    (GAME_CONFIG.BOSS_MIN_DAMAGE +
                        GAME_CONFIG.BOSS_MAX_DAMAGE) /
                        3
                );

                let result = `B·∫°n ph√≤ng th·ªß v√† h·ªìi ${actualHeal} HP!`;

                if (player.shield > 0) {
                    player.shield--;
                    event.battleLog.push({
                        type: "defense",
                        text: `üõ°Ô∏è Khi√™n ch·∫∑n (ph√≤ng th·ªß): ${bossAttack} s√°t th∆∞∆°ng`,
                        calc: `Reduced damage: (${GAME_CONFIG.BOSS_MIN_DAMAGE}+${GAME_CONFIG.BOSS_MAX_DAMAGE})/3 = ${bossAttack}`,
                    });
                    result += `<br>Mr.Ph√∫c t·∫•n c√¥ng nh·∫π ${bossAttack} s√°t th∆∞∆°ng, khi√™n b·∫£o v·ªá ho√†n to√†n! Khi√™n c√≤n: ${player.shield}`;
                } else {
                    event.playerHealth -= bossAttack;
                    event.battleLog.push({
                        type: "damage",
                        text: `üí• Boss t·∫•n c√¥ng (gi·∫£m): ${bossAttack} s√°t th∆∞∆°ng`,
                        calc: `Reduced damage: (${GAME_CONFIG.BOSS_MIN_DAMAGE}+${GAME_CONFIG.BOSS_MAX_DAMAGE})/3 = ${bossAttack}`,
                    });
                    result += `<br>Mr.Ph√∫c t·∫•n c√¥ng nh·∫π ${bossAttack} s√°t th∆∞∆°ng khi b·∫°n ph√≤ng th·ªß!`;
                }

                openModalMsg("üõ°Ô∏è Ph√≤ng Th·ªß", result, [
                    { text: "Ti·∫øp t·ª•c", action: "closeModal" },
                ]);
                closeModal();
                setTimeout(() => startBossFight(event), 1500);
            }
        </script>
    </body>
</html>
