<!DOCTYPE html>
<html lang="vi">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>MLN122 - Maze of Marx (Boss Req + Free Room)</title>
        <style>
            html,
            body {
                height: 100%;
            }
            body {
                margin: 0;
                background: #0b0c12;
                color: #e5e7eb;
                font-family: ui-monospace, Consolas, monospace;
                overflow: hidden;
            }
            header {
                background: #0f1324;
                border-bottom: 2px solid #1e2a4b;
                padding: 10px 12px;
                position: sticky;
                top: 0;
                z-index: 3;
            }
            h1 {
                font-size: 16px;
                margin: 0;
            }
            .hud {
                display: flex;
                gap: 12px;
                flex-wrap: wrap;
                margin-top: 6px;
                font-size: 12px;
            }
            .pill {
                padding: 4px 8px;
                border: 1px solid #1e2a4b;
                border-radius: 999px;
                background: #0c1222;
            }
            .wrap {
                max-width: 1100px;
                margin: 0 auto;
                padding: 12px;
                display: grid;
                gap: 12px;
            }
            .cols {
                display: grid;
                gap: 12px;
            }
            @media (min-width: 980px) {
                .cols {
                    grid-template-columns: 1fr 360px;
                }
            }
            canvas {
                image-rendering: pixelated;
                background: #06070f;
                border: 2px solid #1e2a4b;
                border-radius: 6px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            }
            .panel {
                background: #0f1324;
                border: 1px solid #1e2a4b;
                border-radius: 8px;
                padding: 10px;
            }
            .legend {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
                font-size: 12px;
            }
            button {
                font-family: inherit;
                background: #3a56ff;
                color: #fff;
                border: none;
                border-radius: 8px;
                padding: 10px 12px;
                cursor: pointer;
            }
            button.secondary {
                background: #253052;
            }
            dialog {
                border: 1px solid #1e2a4b;
                border-radius: 10px;
                background: #0c1222;
                color: #e5e7eb;
                max-width: 780px;
            }
            dialog::backdrop {
                background: rgba(0, 0, 0, 0.6);
            }
            .q {
                margin: 0 0 8px 0;
            }
            .opt {
                display: block;
                margin: 8px 0;
            }
            .small {
                font-size: 12px;
                opacity: 0.85;
            }
            /* Comic overlay */
            #overlay {
                position: fixed;
                inset: 0;
                background: #000;
                color: #e5e7eb;
                z-index: 50;
                display: none;
            }
            .comic {
                position: absolute;
                inset: 0;
                display: grid;
                place-items: center;
                padding: 18px;
            }
            .panel-box {
                width: min(920px, 95vw);
                height: min(520px, 70vh);
                background: #111429;
                border: 4px solid #1f2a55;
                border-radius: 12px;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
                display: grid;
                grid-template-rows: 1fr auto;
                overflow: hidden;
            }
            .panel-art {
                background: linear-gradient(120deg, #1a2147, #0f1532);
                display: grid;
                place-items: center;
                padding: 16px;
                font-size: 28px;
            }
            .panel-caption {
                border-top: 2px solid #1f2a55;
                padding: 12px;
                background: #0e1328;
                min-height: 70px;
            }
            .type {
                white-space: pre-wrap;
            }
            .panel-controls {
                position: absolute;
                right: 20px;
                bottom: 16px;
                display: flex;
                gap: 8px;
            }
            .btn {
                background: #3a56ff;
                border: none;
                color: #fff;
                padding: 10px 14px;
                border-radius: 8px;
                cursor: pointer;
            }
            .btn.ghost {
                background: #223;
                color: #aab;
            }
            .blackout {
                position: absolute;
                inset: 0;
                background: #000;
                display: none;
            }
        </style>
    </head>
    <body>
        <header>
            <div class="wrap">
                <h1>MLN122 - Maze of Marx (20 Ph√≤ng | WASD)</h1>
                <div class="hud">
                    <span class="pill"
                        >‚è±Ô∏è Th·ªùi gian: <b id="time">15:00</b></span
                    >
                    <span class="pill">‚ù§Ô∏è M·∫°ng: <b id="lives">3</b></span>
                    <span class="pill">üóùÔ∏è Ph√≤ng: <b id="room">0 / 20</b></span>
                    <span class="pill">‚≠ê ƒêi·ªÉm: <b id="score">0</b></span>
                    <span class="pill">üéÆ ƒêi·ªÅu khi·ªÉn: WASD / M≈©i t√™n</span>
                </div>
            </div>
        </header>

        <main class="wrap cols">
            <section>
                <canvas id="cv" width="544" height="544"></canvas>
            </section>
            <aside class="panel">
                <h3 style="margin-top: 0">Ch√∫ gi·∫£i</h3>
                <div class="legend">
                    <div>üü© ƒê∆∞·ªùng</div>
                    <div>üß± T∆∞·ªùng</div>
                    <div>üîµ H: Hint</div>
                    <div>üü° Q: Quiz</div>
                    <div>‚ò†Ô∏è X: B·∫´y</div>
                    <div>‚¨ú C·ªïng ra</div>
                    <div>üü£ B: Boss</div>
                    <div>üü† T: Teleport</div>
                    <div>üü™ C: R∆∞∆°ng</div>
                    <div>üõå REST: ph√≤ng 4 c·ªïng</div>
                </div>
                <button id="btnReset" class="secondary">Reset & Random</button>
            </aside>
        </main>

        <!-- Comic overlay -->
        <div id="overlay">
            <div class="blackout" id="black"></div>
            <div class="comic">
                <div class="panel-box">
                    <div class="panel-art" id="art">üìï</div>
                    <div class="panel-caption">
                        <div class="type" id="caption"></div>
                        <div class="panel-controls">
                            <button class="btn ghost" id="skip">B·ªè qua</button>
                            <button class="btn" id="next">Ti·∫øp</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <dialog id="modalQ">
            <form method="dialog">
                <h3 id="qTitle">C√¢u h·ªèi</h3>
                <p id="qText" class="q"></p>
                <div id="opts"></div>
                <div class="small" id="hintArea"></div>
                <div style="margin-top: 10px">
                    <button value="close" class="secondary">ƒê√≥ng</button>
                </div>
            </form>
        </dialog>

        <dialog id="modalMsg">
            <form method="dialog">
                <h3 id="msgTitle">Th√¥ng b√°o</h3>
                <p id="msgText"></p>
                <button value="ok">OK</button>
            </form>
        </dialog>

        <script>
            const TILE = 32,
                N = 17,
                TOTAL_ROOMS = 20;
            const COUNTS = {
                quiz: 10,
                hint: 4,
                death: 2,
                rest: 2,
                boss: 1,
                mech: 1,
            };
            const INTERACT_QUIZ = 10,
                TIMER_SEC = 15 * 60,
                START_LIVES = 3,
                SPEED = 1;
            const cv = document.getElementById("cv"),
                ctx = cv.getContext("2d");
            const timeEl = document.getElementById("time"),
                livesEl = document.getElementById("lives"),
                roomEl = document.getElementById("room"),
                scoreEl = document.getElementById("score");
            const modalQ = document.getElementById("modalQ"),
                qTitle = document.getElementById("qTitle"),
                qText = document.getElementById("qText"),
                optsBox = document.getElementById("opts"),
                hintArea = document.getElementById("hintArea");
            const modalMsg = document.getElementById("modalMsg"),
                msgTitle = document.getElementById("msgTitle"),
                msgText = document.getElementById("msgText");
            const overlay = document.getElementById("overlay"),
                art = document.getElementById("art"),
                caption = document.getElementById("caption"),
                nextBtn = document.getElementById("next"),
                skipBtn = document.getElementById("skip"),
                blackDiv = document.getElementById("black");

            /* Comic panels */
            const introPanels = [
                {
                    art: "üìï",
                    text: 'Th·∫ßy d·∫∑n: "S·∫£n ph·∫©m kh√¥ng r√µ \nM·ª•c ƒë√≠ch - M·ª•c ti√™u - √ù nghƒ©a l√† GAME OVER."',
                },
                {
                    art: "üïµÔ∏è",
                    text: '"C√≥ gi√°n ƒëi·ªáp theo d√µi game c·ªßa c√°c em." \nH√£y ch·ª©ng minh gi√° tr·ªã h·ªçc thu·∫≠t!',
                },
                {
                    art: "üè≠‚ù§Ô∏è",
                    text: "S·ª© m·ªánh: t·∫°o GI√Å TR·ªä TH·∫∂NG D∆Ø \nnh∆∞ng v·∫´n gi·ªØ C√îNG B·∫∞NG X√É H·ªòI.",
                },
                {
                    art: "üß≠",
                    text: "V∆∞·ª£t 20 ph√≤ng: Quiz, Hint, Boss Ph√∫c, Teleport, Death‚Ä¶ \nThu th·∫≠p r∆∞∆°ng v√† tho√°t ra ƒë√∫ng h·∫°n!",
                },
            ];
            const outroPanels = [
                { art: "üéì", text: "H√†nh tr√¨nh k·∫øt th√∫c." },
                { art: "üèÖ", text: "Ph·∫ßn th∆∞·ªüng: Doanh nghi·ªáp b·ªÅn v·ªØng." },
                {
                    art: "üìú",
                    text: "B√†i h·ªçc: L·ª£i nhu·∫≠n ph·∫£i ƒëi c√πng c√¥ng b·∫±ng.",
                },
            ];
            let comicMode = "intro",
                panelIndex = 0,
                typingId = null;
            function showOverlay(kind) {
                comicMode = kind;
                panelIndex = 0;
                overlay.style.display = "block";
                typePanel();
            }
            function typePanel() {
                const arr = comicMode === "intro" ? introPanels : outroPanels;
                const p = arr[panelIndex];
                art.textContent = p.art;
                caption.textContent = "";
                let i = 0;
                clearInterval(typingId);
                typingId = setInterval(() => {
                    caption.textContent = p.text.slice(0, ++i);
                    if (i >= p.text.length) clearInterval(typingId);
                }, 18);
            }
            nextBtn.onclick = () => {
                const arr = comicMode === "intro" ? introPanels : outroPanels;
                if (panelIndex < arr.length - 1) {
                    panelIndex++;
                    typePanel();
                } else {
                    blackDiv.style.display = "block";
                    blackDiv.style.opacity = 1;
                    overlay.innerHTML =
                        '<div class="comic"><button id="playBtn" class="btn" style="padding:16px 22px">‚ñ∂ Play</button></div>';
                    document.getElementById("playBtn").onclick = () => {
                        overlay.style.display = "none";
                        startGame();
                    };
                }
            };
            skipBtn.onclick = () => {
                overlay.style.display = "none";
                startGame();
            };

            /* Bank */
            const bank = [
                {
                    tag: "H√†ng ho√°",
                    q: "Theo M√°c, h√†ng ho√° c√≥ m·∫•y thu·ªôc t√≠nh c∆° b·∫£n?",
                    a: "Hai: gi√° tr·ªã s·ª≠ d·ª•ng v√† gi√° tr·ªã",
                    choices: [
                        "Hai: gi√° tr·ªã s·ª≠ d·ª•ng v√† gi√° tr·ªã",
                        "M·ªôt: gi√° tr·ªã",
                        "Ba: gi√° tr·ªã, gi√° c·∫£, l·ª£i nhu·∫≠n",
                        "B·ªën: gi√° tr·ªã, gi√° tr·ªã s·ª≠ d·ª•ng, gi√° c·∫£, th·∫∑ng d∆∞",
                    ],
                    hint: "Hai thu·ªôc t√≠nh: gi√° tr·ªã s·ª≠ d·ª•ng & gi√° tr·ªã.",
                },
                {
                    tag: "S·∫£n xu·∫•t h√†ng ho√°",
                    q: "ƒêi·ªÅu ki·ªán ra ƒë·ªùi c·ªßa s·∫£n xu·∫•t h√†ng ho√° KH√îNG g·ªìm?",
                    a: "T·∫≠p trung t∆∞ b·∫£n cao ƒë·ªô",
                    choices: [
                        "Ph√¢n c√¥ng lao ƒë·ªông x√£ h·ªôi",
                        "T√°ch bi·ªát kinh t·∫ø gi·ªØa c√°c ch·ªß th·ªÉ",
                        "Trao ƒë·ªïi qua th·ªã tr∆∞·ªùng",
                        "T·∫≠p trung t∆∞ b·∫£n cao ƒë·ªô",
                    ],
                    hint: "Hai ƒëi·ªÅu ki·ªán ch√≠nh: ph√¢n c√¥ng Lƒê & t√°ch bi·ªát kinh t·∫ø.",
                },
                {
                    tag: "Ti·ªÅn t·ªá",
                    q: "Ch·ª©c nƒÉng th∆∞·ªõc ƒëo gi√° tr·ªã thu·ªôc v·ªÅ?",
                    a: "Ti·ªÅn t·ªá",
                    choices: ["Ti·ªÅn t·ªá", "H√†ng ho√°", "T∆∞ b·∫£n", "Ti·ªÅn c√¥ng"],
                    hint: "Ch·ª©c nƒÉng c·ªßa ti·ªÅn t·ªá.",
                },
                {
                    tag: "Gi√° tr·ªã",
                    q: "Gi√° tr·ªã h√†ng ho√° do c√°i g√¨ quy·∫øt ƒë·ªãnh?",
                    a: "Lao ƒë·ªông x√£ h·ªôi c·∫ßn thi·∫øt",
                    choices: [
                        "Kh·∫£ nƒÉng mua",
                        "Cung - c·∫ßu",
                        "Lao ƒë·ªông x√£ h·ªôi c·∫ßn thi·∫øt",
                        "Uy t√≠n th∆∞∆°ng hi·ªáu",
                    ],
                    hint: "L∆∞·ª£ng gi√° tr·ªã ‚àù th·ªùi gian lao ƒë·ªông XH c·∫ßn thi·∫øt.",
                },
                {
                    tag: "Gi√° tr·ªã th·∫∑ng d∆∞",
                    q: "Ngu·ªìn g·ªëc gi√° tr·ªã th·∫∑ng d∆∞ l√† g√¨?",
                    a: "Lao ƒë·ªông th·∫∑ng d∆∞ c·ªßa c√¥ng nh√¢n l√†m thu√™",
                    choices: [
                        "M√°y m√≥c t·∫°o ra",
                        "ƒê·ªïi ch√°c t·∫°o ra",
                        "Thu·∫ø t·∫°o ra",
                        "Lao ƒë·ªông th·∫∑ng d∆∞ c·ªßa c√¥ng nh√¢n l√†m thu√™",
                    ],
                    hint: "Tr·ªçng t√¢m h·ªçc thuy·∫øt M√°c.",
                },
                {
                    tag: "B√≥c l·ªôt",
                    q: "B·∫£n ch·∫•t b√≥c l·ªôt trong CNTB?",
                    a: "Chi·∫øm ƒëo·∫°t lao ƒë·ªông th·∫∑ng d∆∞",
                    choices: [
                        "√âp gi√° b√°n",
                        "Chi·∫øm ƒëo·∫°t lao ƒë·ªông th·∫∑ng d∆∞",
                        "H·∫° ch·∫•t l∆∞·ª£ng",
                        "Gi·∫£m c·∫°nh tranh",
                    ],
                    hint: "Chi·∫øm ƒëo·∫°t M.",
                },
                {
                    tag: "M tuy·ªát ƒë·ªëi",
                    q: "TƒÉng c∆∞·ªùng ƒë·ªô lao ƒë·ªông l√† ph∆∞∆°ng ph√°p t·∫°o M n√†o?",
                    a: "Tuy·ªát ƒë·ªëi",
                    choices: [
                        "Tuy·ªát ƒë·ªëi",
                        "T∆∞∆°ng ƒë·ªëi",
                        "Si√™u ng·∫°ch",
                        "Kh√¥ng thu·ªôc",
                    ],
                    hint: "Tuy·ªát ƒë·ªëi: k√©o d√†i/ tƒÉng c∆∞·ªùng ƒë·ªô Lƒê.",
                },
                {
                    tag: "M t∆∞∆°ng ƒë·ªëi",
                    q: "TƒÉng nƒÉng su·∫•t lao ƒë·ªông nh·∫±m r√∫t ng·∫Øn Lƒê t·∫•t y·∫øu l√† M lo·∫°i g√¨?",
                    a: "T∆∞∆°ng ƒë·ªëi",
                    choices: [
                        "Tuy·ªát ƒë·ªëi",
                        "T∆∞∆°ng ƒë·ªëi",
                        "Si√™u ng·∫°ch",
                        "Kh√¥ng thu·ªôc",
                    ],
                    hint: "M t∆∞∆°ng ƒë·ªëi nh·ªù NSLƒê.",
                },
                {
                    tag: "Si√™u ng·∫°ch",
                    q: "Gi√° tr·ªã th·∫∑ng d∆∞ si√™u ng·∫°ch c√≥ ƒë∆∞·ª£c khi?",
                    a: "Doanh nghi·ªáp c√≥ nƒÉng su·∫•t v∆∞·ª£t tr·ªôi so v·ªõi TB x√£ h·ªôi",
                    choices: [
                        "TƒÉng gi·ªù l√†m",
                        "TƒÉng l∆∞∆°ng",
                        "Doanh nghi·ªáp c√≥ nƒÉng su·∫•t v∆∞·ª£t tr·ªôi so v·ªõi TB x√£ h·ªôi",
                        "Kh√¥ng li√™n quan nƒÉng su·∫•t",
                    ],
                    hint: "NS c√° bi·ªát < NSXH.",
                },
                {
                    tag: "T√≠ch lu·ªπ",
                    q: "T√≠ch lu·ªπ t∆∞ b·∫£n l√†m tƒÉng ch·ªß y·∫øu?",
                    a: "Quy m√¥ t∆∞ b·∫£n c√° bi·ªát",
                    choices: [
                        "Quy m√¥ t∆∞ b·∫£n c√° bi·ªát",
                        "L∆∞∆°ng th·ª±c t·∫ø",
                        "Th·ªùi gian ngh·ªâ",
                        "Thu·∫ø VAT",
                    ],
                    hint: "T√≠ch t·ª• + t·∫≠p trung.",
                },
                {
                    tag: "ƒê·ªôc quy·ªÅn",
                    q: "ƒê·∫∑c ƒëi·ªÉm KH√îNG ph·∫£i c·ªßa ch·ªß nghƒ©a ƒë·∫ø qu·ªëc theo L√™nin?",
                    a: "Xo√° b·ªè ho√†n to√†n th·ªã tr∆∞·ªùng th·∫ø gi·ªõi",
                    choices: [
                        "T·∫≠p trung s·∫£n xu·∫•t & ƒë·ªôc quy·ªÅn",
                        "T∆∞ b·∫£n t√†i ch√≠nh",
                        "Xu·∫•t kh·∫©u t∆∞ b·∫£n",
                        "Xo√° b·ªè ho√†n to√†n th·ªã tr∆∞·ªùng th·∫ø gi·ªõi",
                    ],
                    hint: "5 ƒë·∫∑c ƒëi·ªÉm.",
                },
                {
                    tag: "Th·ªã tr∆∞·ªùng",
                    q: "Vai tr√≤ c∆° b·∫£n c·ªßa th·ªã tr∆∞·ªùng?",
                    a: "Ph√¢n b·ªï ngu·ªìn l·ª±c th√¥ng qua gi√° c·∫£",
                    choices: [
                        "Ph√¢n b·ªï ngu·ªìn l·ª±c th√¥ng qua gi√° c·∫£",
                        "TƒÉng l·∫°m ph√°t",
                        "Gi·∫£m c·∫°nh tranh",
                        "Lo·∫°i b·ªè Nh√† n∆∞·ªõc",
                    ],
                    hint: "C∆° ch·∫ø gi√°.",
                },
                {
                    tag: "KTTT ƒë·ªãnh h∆∞·ªõng XHCN",
                    q: "M·ªôt ƒë·∫∑c tr∆∞ng c·ªßa KTTT ƒë·ªãnh h∆∞·ªõng XHCN ·ªü VN?",
                    a: "K·∫øt h·ª£p hi·ªáu qu·∫£ v·ªõi c√¥ng b·∫±ng x√£ h·ªôi",
                    choices: [
                        "Ch·ªâ l·ª£i nhu·∫≠n",
                        "Lo·∫°i b·ªè s·ªü h·ªØu t∆∞ nh√¢n",
                        "K·∫øt h·ª£p hi·ªáu qu·∫£ v·ªõi c√¥ng b·∫±ng x√£ h·ªôi",
                        "Kh√¥ng c·∫ßn NN",
                    ],
                    hint: "ƒê·∫∑c tr∆∞ng.",
                },
                {
                    tag: "CNH-HƒêH",
                    q: "H·ªôi nh·∫≠p kinh t·∫ø qu·ªëc t·∫ø KH√îNG g·ªìm?",
                    a: "C√¥ l·∫≠p th∆∞∆°ng m·∫°i",
                    choices: [
                        "FTA",
                        "Li√™n minh thu·∫ø quan",
                        "Li√™n minh kinh t·∫ø",
                        "C√¥ l·∫≠p th∆∞∆°ng m·∫°i",
                    ],
                    hint: "C√°c c·∫•p ƒë·ªô.",
                },
                {
                    tag: "Ti·ªÅn c√¥ng",
                    q: "Ti·ªÅn c√¥ng l√†?",
                    a: "Gi√° c·∫£ c·ªßa s·ª©c lao ƒë·ªông",
                    choices: [
                        "Gi√° c·∫£ c·ªßa s·ª©c lao ƒë·ªông",
                        "Gi√° c·∫£ h√†ng ho√°",
                        "Ti·ªÅn boa",
                        "Thu·∫ø thu nh·∫≠p",
                    ],
                    hint: "H√†ng ho√° ƒë·∫∑c bi·ªát.",
                },
                {
                    tag: "T√°i s·∫£n xu·∫•t",
                    q: "T√°i s·∫£n xu·∫•t m·ªü r·ªông l√†?",
                    a: "Quy m√¥ s·∫£n xu·∫•t tƒÉng l√™n qua c√°c chu k·ª≥",
                    choices: [
                        "Gi·ªØ nguy√™n quy m√¥",
                        "Quy m√¥ s·∫£n xu·∫•t tƒÉng l√™n qua c√°c chu k·ª≥",
                        "Gi·∫£m v·ªën",
                        "Ch·ªâ tƒÉng Lƒê",
                    ],
                    hint: "M·ª•c ti√™u t√≠ch lu·ªπ.",
                },
                {
                    tag: "C·∫°nh tranh",
                    q: "H·ªá qu·∫£ t√≠ch c·ª±c c·ªßa c·∫°nh tranh?",
                    a: "Th√∫c ƒë·∫©y ƒë·ªïi m·ªõi v√† hi·ªáu qu·∫£",
                    choices: [
                        "T·∫°o ƒë·ªôc quy·ªÅn ngay",
                        "Th√∫c ƒë·∫©y ƒë·ªïi m·ªõi v√† hi·ªáu qu·∫£",
                        "Gi·∫£m nƒÉng su·∫•t",
                        "Hu·ª∑ th·ªã tr∆∞·ªùng",
                    ],
                    hint: "Song tr√πng t√≠ch c·ª±c/ti√™u c·ª±c.",
                },
                {
                    tag: "ƒê·ªôc quy·ªÅn t·ª± nhi√™n",
                    q: "V√¨ sao c·∫ßn qu·∫£n l√Ω ƒë·ªôc quy·ªÅn t·ª± nhi√™n?",
                    a: "ƒê·∫£m b·∫£o l·ª£i √≠ch x√£ h·ªôi & ng∆∞·ªùi ti√™u d√πng",
                    choices: [
                        "T·ªëi ƒëa ho√° l·ª£i nhu·∫≠n t∆∞ nh√¢n",
                        "ƒê·∫£m b·∫£o l·ª£i √≠ch x√£ h·ªôi & ng∆∞·ªùi ti√™u d√πng",
                        "Kh√¥ng ai ƒë∆∞·ª£c kinh doanh",
                        "TƒÉng gi√° tu·ª≥ √Ω",
                    ],
                    hint: "ƒêi·ªÅu ti·∫øt NN.",
                },
                {
                    tag: "Vai tr√≤ NN",
                    q: "Trong KTTT ƒë·ªãnh h∆∞·ªõng XHCN, NN c√≥ vai tr√≤?",
                    a: "ƒê·ªãnh h∆∞·ªõng, ƒëi·ªÅu ti·∫øt, b·∫£o ƒë·∫£m c√¥ng b·∫±ng",
                    choices: [
                        "Kh√¥ng can thi·ªáp",
                        "Ch·ªâ thu thu·∫ø",
                        "ƒê·ªãnh h∆∞·ªõng, ƒëi·ªÅu ti·∫øt, b·∫£o ƒë·∫£m c√¥ng b·∫±ng",
                        "Kinh doanh m·ªçi ng√†nh",
                    ],
                    hint: "Vai tr√≤ ƒëa chi·ªÅu.",
                },
                {
                    tag: "S·ªü h·ªØu",
                    q: "Ch·∫ø ƒë·ªô s·ªü h·ªØu ·ªü VN?",
                    a: "ƒêa d·∫°ng: nh√† n∆∞·ªõc, t·∫≠p th·ªÉ, t∆∞ nh√¢n...",
                    choices: [
                        "Ch·ªâ nh√† n∆∞·ªõc",
                        "Ch·ªâ t∆∞ nh√¢n",
                        "ƒêa d·∫°ng: nh√† n∆∞·ªõc, t·∫≠p th·ªÉ, t∆∞ nh√¢n...",
                        "Kh√¥ng s·ªü h·ªØu",
                    ],
                    hint: "Nhi·ªÅu h√¨nh th·ª©c.",
                },
            ];

            /* State */
            let lives = START_LIVES,
                score = 0,
                timer = TIMER_SEC;
            let pool = [],
                roomKind = "",
                roomData = null,
                roomCount = 0;
            let maze, player, exitTile;
            let bossTicker = null,
                bossReq = 30; // randomized on boss room
            function rand(n) {
                return Math.floor(Math.random() * n);
            }
            function shuffle(a) {
                for (let i = a.length - 1; i > 0; i--) {
                    const j = rand(i + 1);
                    [a[i], a[j]] = [a[j], a[i]];
                }
                return a;
            }

            /* Maze helpers */
            function genMaze() {
                const g = Array.from({ length: N }, () =>
                    Array.from({ length: N }, () => 1)
                );
                (function carve(x, y) {
                    g[y][x] = 0;
                    for (const [dx, dy] of shuffle([
                        [2, 0],
                        [-2, 0],
                        [0, 2],
                        [0, -2],
                    ])) {
                        const nx = x + dx,
                            ny = y + dy;
                        if (
                            nx > 0 &&
                            nx < N - 1 &&
                            ny > 0 &&
                            ny < N - 1 &&
                            g[ny][nx] === 1
                        ) {
                            g[y + dy / 2][x + dx / 2] = 0;
                            carve(nx, ny);
                        }
                    }
                })(1, 1);
                return g;
            }
            function openCells(g) {
                const c = [];
                for (let y = 1; y < N - 1; y++)
                    for (let x = 1; x < N - 1; x++)
                        if (g[y][x] === 0) c.push({ x, y });
                return c;
            }
            function farExit(g) {
                const cells = openCells(g);
                let best = cells[0],
                    d = 0;
                for (const p of cells) {
                    const dd = (p.x - 1) ** 2 + (p.y - 1) ** 2;
                    if (dd > d) {
                        d = dd;
                        best = p;
                    }
                }
                return best;
            }

            /* Rooms */
            function newRoom() {
                if (bossTicker) {
                    clearInterval(bossTicker);
                    bossTicker = null;
                }
                const kind = pool.pop();
                roomKind = kind;
                roomCount++;
                updateHUD();
                // Build map
                if (kind === "rest") {
                    // FREE room: no maze, open field with 4 gates
                    maze = Array.from({ length: N }, () =>
                        Array.from({ length: N }, () => 0)
                    ); // all walkable
                    player = { x: Math.floor(N / 2), y: Math.floor(N / 2) };
                    exitTile = { x: -1, y: -1 }; // no single exit
                    roomData = {
                        gates: [
                            { x: Math.floor(N / 2), y: 1 },
                            { x: N - 2, y: Math.floor(N / 2) },
                            { x: Math.floor(N / 2), y: N - 2 },
                            { x: 1, y: Math.floor(N / 2) },
                        ],
                        chests: [],
                    };
                } else {
                    maze = genMaze();
                    player = { x: 1, y: 1 };
                    exitTile = farExit(maze);
                }

                if (kind === "quiz") {
                    const qs = [],
                        b = shuffle(bank.slice());
                    while (qs.length < INTERACT_QUIZ) {
                        qs.push(b[qs.length % b.length]);
                    }
                    const cells = shuffle(
                        openCells(maze).filter(
                            (c) =>
                                !(c.x === player.x && c.y === player.y) &&
                                !(c.x === exitTile.x && c.y === exitTile.y)
                        )
                    );
                    const tiles = cells.slice(0, INTERACT_QUIZ);
                    roomData = {
                        questions: qs,
                        tiles,
                        answered: Array(INTERACT_QUIZ).fill(false),
                        chests: cells.slice(INTERACT_QUIZ, INTERACT_QUIZ + 3),
                    };
                } else if (kind === "hint") {
                    const hints = [
                        "S·∫Øp t·ªõi: Gi√° tr·ªã th·∫∑ng d∆∞",
                        "Ch√∫ √Ω: h√†ng ho√° & hai thu·ªôc t√≠nh",
                        "Vai tr√≤ Nh√† n∆∞·ªõc trong KTTT ƒë·ªãnh h∆∞·ªõng XHCN",
                        "Ph√¢n bi·ªát: M tuy·ªát ƒë·ªëi/ t∆∞∆°ng ƒë·ªëi/ si√™u ng·∫°ch",
                        "ƒê·∫∑c ƒëi·ªÉm CN ƒë·∫ø qu·ªëc theo L√™nin",
                    ];
                    const cells = shuffle(
                        openCells(maze).filter(
                            (c) =>
                                !(c.x === player.x && c.y === player.y) &&
                                !(c.x === exitTile.x && c.y === exitTile.y)
                        )
                    );
                    roomData = {
                        tiles: cells.slice(0, 7),
                        hints,
                        chests: cells.slice(7, 10),
                    };
                } else if (kind === "death") {
                    const cells = shuffle(
                        openCells(maze).filter(
                            (c) =>
                                !(c.x === player.x && c.y === player.y) &&
                                !(c.x === exitTile.x && c.y === exitTile.y)
                        )
                    );
                    roomData = {
                        traps: cells.slice(0, 22),
                        chests: cells.slice(22, 25),
                    };
                } else if (kind === "boss") {
                    const cells = openCells(maze);
                    const missiles = [];
                    for (let i = 0; i < 6; i++) {
                        const p = cells[rand(cells.length)];
                        const dir =
                            Math.random() < 0.5
                                ? { dx: 1, dy: 0 }
                                : { dx: 0, dy: 1 };
                        missiles.push({
                            x: p.x,
                            y: p.y,
                            dx: dir.dx,
                            dy: dir.dy,
                        });
                    }
                    bossReq = Math.max(26, 20 + rand(31)); // random 26..50
                    roomData = { missiles, chests: [] };
                    openModalMsg(
                        "Boss Ph√∫c üëπ",
                        `ƒêi·ªÉm y√™u c·∫ßu: <b>${bossReq}</b>. N·∫øu ƒëi·ªÉm hi·ªán t·∫°i (${score}) < ${bossReq}, khi ch·∫°m c·ªïng s·∫Ω b·ªã <b>Th·∫ßy Ph√∫c</b> b·∫Øn g·ª•c!`
                    );
                    bossTicker = setInterval(() => {
                        roomData.missiles.forEach((m) => {
                            let nx = m.x + m.dx,
                                ny = m.y + m.dy;
                            if (
                                nx <= 0 ||
                                ny <= 0 ||
                                nx >= N - 1 ||
                                ny >= N - 1 ||
                                maze[ny][nx] === 1
                            ) {
                                m.dx *= -1;
                                m.dy *= -1;
                                nx = m.x + m.dx;
                                ny = m.y + m.dy;
                            }
                            if (maze[ny][nx] === 0) {
                                m.x = nx;
                                m.y = ny;
                            }
                            if (player.x === m.x && player.y === m.y) {
                                loseLife("B·∫°n tr√∫ng t√™n l·ª≠a ƒë·ªè c·ªßa Boss Ph√∫c.");
                            }
                        });
                        draw();
                    }, 160);
                } else if (kind === "mech") {
                    const cells = shuffle(
                        openCells(maze).filter(
                            (c) =>
                                !(c.x === player.x && c.y === player.y) &&
                                !(c.x === exitTile.x && c.y === exitTile.y)
                        )
                    );
                    roomData = {
                        pads: cells.slice(0, 4),
                        chests: cells.slice(4, 7),
                    };
                }
                draw();
            }

            function draw() {
                ctx.clearRect(0, 0, cv.width, cv.height);
                for (let y = 0; y < N; y++) {
                    for (let x = 0; x < N; x++) {
                        ctx.fillStyle =
                            maze[y][x] === 1 ? "#1f243b" : "#0f1530";
                        ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
                    }
                }
                if (roomKind === "quiz") {
                    ctx.fillStyle = "#facc15";
                    roomData.tiles.forEach((t, i) => {
                        if (!roomData.answered[i])
                            ctx.fillRect(
                                t.x * TILE + 10,
                                t.y * TILE + 10,
                                TILE - 20,
                                TILE - 20
                            );
                    });
                }
                if (roomKind === "hint") {
                    ctx.fillStyle = "#38bdf8";
                    roomData.tiles.forEach((t) =>
                        ctx.fillRect(
                            t.x * TILE + 10,
                            t.y * TILE + 10,
                            TILE - 20,
                            TILE - 20
                        )
                    );
                }
                if (roomKind === "death") {
                    ctx.fillStyle = "#ef4444";
                    roomData.traps.forEach((t) =>
                        ctx.fillRect(
                            t.x * TILE + 8,
                            t.y * TILE + 8,
                            TILE - 16,
                            TILE - 16
                        )
                    );
                }
                if (roomKind === "rest") {
                    ctx.fillStyle = "#a3e635";
                    roomData.gates.forEach((g) =>
                        ctx.fillRect(
                            g.x * TILE + 6,
                            g.y * TILE + 6,
                            TILE - 12,
                            TILE - 12
                        )
                    );
                }
                if (roomKind === "boss") {
                    ctx.fillStyle = "#ef4444";
                    roomData.missiles.forEach((m) =>
                        ctx.fillRect(
                            m.x * TILE + 8,
                            m.y * TILE + 8,
                            TILE - 16,
                            TILE - 16
                        )
                    );
                }
                if (roomKind === "mech") {
                    ctx.fillStyle = "#f97316";
                    roomData.pads.forEach((p) =>
                        ctx.fillRect(
                            p.x * TILE + 8,
                            p.y * TILE + 8,
                            TILE - 16,
                            TILE - 16
                        )
                    );
                }
                // chests
                if (roomData && roomData.chests) {
                    ctx.fillStyle = "#a855f7";
                    roomData.chests.forEach((c) =>
                        ctx.fillRect(
                            c.x * TILE + 10,
                            c.y * TILE + 10,
                            TILE - 20,
                            TILE - 20
                        )
                    );
                }
                // exit for all except rest
                if (roomKind !== "rest") {
                    ctx.fillStyle = "#a78bfa";
                    ctx.fillRect(
                        exitTile.x * TILE + 8,
                        exitTile.y * TILE + 8,
                        TILE - 16,
                        TILE - 16
                    );
                }
                // player
                ctx.fillStyle = "#e5e7eb";
                ctx.beginPath();
                ctx.arc(
                    player.x * TILE + TILE / 2,
                    player.y * TILE + TILE / 2,
                    6,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                // label
                ctx.fillStyle = "#94a3b8";
                ctx.fillText(
                    `Ph√≤ng ${roomCount}/${TOTAL_ROOMS} - ${roomKind.toUpperCase()}`,
                    8,
                    16
                );
            }

            function updateHUD() {
                livesEl.textContent = lives;
                scoreEl.textContent = score;
                roomEl.textContent = `${roomCount} / ${TOTAL_ROOMS}`;
            }
            function openModalMsg(t, h) {
                msgTitle.textContent = t;
                msgText.innerHTML = h;
                modalMsg.showModal();
            }
            function formatTime(s) {
                const m = String(Math.floor(s / 60)).padStart(2, "0");
                const r = String(s % 60).padStart(2, "0");
                return `${m}:${r}`;
            }
            let timerId = null;
            function startTimer() {
                if (timerId) clearInterval(timerId);
                timerId = setInterval(() => {
                    timer--;
                    timeEl.textContent = formatTime(timer);
                    if (timer <= 0) {
                        showOverlay("outro");
                    }
                }, 1000);
            }

            /* Flow */
            function buildPool() {
                const arr = [];
                Object.keys(COUNTS).forEach((k) => {
                    for (let i = 0; i < COUNTS[k]; i++) arr.push(k);
                });
                return shuffle(arr);
            }
            function resetGame(showMsg = false) {
                lives = START_LIVES;
                score = 0;
                timer = TIMER_SEC;
                timeEl.textContent = formatTime(timer);
                startTimer();
                roomCount = 0;
                pool = buildPool();
                // Force first room REST
                let i = pool.indexOf("rest");
                if (i > -1) {
                    const t = pool.splice(i, 1)[0];
                    pool.push(t);
                }
                if (showMsg)
                    openModalMsg(
                        "Reset",
                        "ƒê√£ x√°o tr·ªôn ph√≤ng. B·∫Øt ƒë·∫ßu ·ªü ph√≤ng REST."
                    );
                newRoom();
            }
            function startGame() {
                resetGame();
            }
            function nextRoom() {
                if (roomCount >= TOTAL_ROOMS) {
                    showOverlay("outro");
                } else {
                    newRoom();
                }
            }
            function loseLife(reason) {
                lives--;
                updateHUD();
                if (lives <= 0) {
                    showOverlay("outro");
                    return;
                }
                player = {
                    x: roomKind === "rest" ? Math.floor(N / 2) : 1,
                    y: roomKind === "rest" ? Math.floor(N / 2) : 1,
                };
                draw();
                if (reason) openModalMsg("M·∫•t m·∫°ng", reason);
            }

            /* Interactions */
            function stepOn(x, y) {
                // chests
                if (roomData && roomData.chests) {
                    const k = roomData.chests.findIndex(
                        (c) => c.x === x && c.y === y
                    );
                    if (k > -1) {
                        const prize = rand(4);
                        let msg = "";
                        if (prize == 0 && lives < START_LIVES) {
                            lives++;
                            msg = "+1 m·∫°ng";
                        } else if (prize == 1) {
                            timer = Math.min(timer + 60, TIMER_SEC);
                            msg = "+60s";
                        } else if (prize == 2) {
                            score += 10;
                            msg = "+10 ƒëi·ªÉm";
                        } else {
                            window.hasShield = true;
                            msg = "Khi√™n 1 l·∫ßn";
                        }
                        roomData.chests.splice(k, 1);
                        updateHUD();
                        openModalMsg("R∆∞∆°ng üéÅ", msg);
                        draw();
                        return;
                    }
                }
                // exit
                if (
                    roomKind !== "rest" &&
                    x === exitTile.x &&
                    y === exitTile.y
                ) {
                    if (
                        roomKind === "quiz" &&
                        !roomData.answered.every((v) => v)
                    ) {
                        openModalMsg("C·ªïng kho√°", "C·∫ßn tr·∫£ l·ªùi ƒë·ªß 10/10 c√¢u.");
                        return;
                    }
                    if (roomKind === "boss" && score < bossReq) {
                        loseLife(
                            `ƒêi·ªÉm ${score} < y√™u c·∫ßu ${bossReq}. <b>Th·∫ßy Ph√∫c</b> b·∫Øn g·ª•c b·∫°n!`
                        );
                        return;
                    }
                    score += 10;
                    nextRoom();
                    return;
                }
                if (roomKind === "quiz") {
                    roomData.tiles.forEach((t, i) => {
                        if (!roomData.answered[i] && t.x === x && t.y === y)
                            askQuestion(i);
                    });
                }
                if (roomKind === "hint") {
                    roomData.tiles.forEach((t, i) => {
                        if (t.x === x && t.y === y) {
                            const tips = [
                                "Gi√° tr·ªã th·∫∑ng d∆∞",
                                "Th·ªã tr∆∞·ªùng",
                                "Ti·ªÅn t·ªá",
                                "ƒê·ªôc quy·ªÅn",
                                "Vai tr√≤ Nh√† n∆∞·ªõc",
                            ];
                            openModalMsg("Hint üîç", tips[i % tips.length]);
                            score += 1;
                        }
                    });
                }
                if (roomKind === "death") {
                    roomData.traps.forEach((t) => {
                        if (t.x === x && t.y === y) {
                            if (window.hasShield) {
                                window.hasShield = false;
                                openModalMsg("Khi√™n üõ°Ô∏è", "B·∫°n tho√°t b·∫´y!");
                            } else loseLife("B·∫°n d·∫´m b·∫´y.");
                        }
                    });
                }
                if (roomKind === "rest") {
                    const gate = [
                        { x: Math.floor(N / 2), y: 1 },
                        { x: N - 2, y: Math.floor(N / 2) },
                        { x: Math.floor(N / 2), y: N - 2 },
                        { x: 1, y: Math.floor(N / 2) },
                    ].find((g) => g.x === x && g.y === y);
                    if (gate) {
                        score += 3;
                        nextRoom();
                    }
                }
                if (roomKind === "mech") {
                    const pad = roomData.pads.find(
                        (p) => p.x === x && p.y === y
                    );
                    if (pad) {
                        const others = roomData.pads.filter(
                            (p) => !(p.x === x && p.y === y)
                        );
                        const tp = others[rand(others.length)];
                        player.x = tp.x;
                        player.y = tp.y;
                        draw();
                    }
                }
            }
            function askQuestion(idx) {
                const it = roomData.questions[idx];
                qTitle.textContent = `C√¢u h·ªèi MLN122 (${
                    idx + 1
                }/${INTERACT_QUIZ}) - ${it.tag}`;
                qText.innerHTML = it.q;
                hintArea.textContent = "G·ª£i √Ω: " + it.hint;
                optsBox.innerHTML = "";
                const opts = shuffle(it.choices.slice());
                opts.forEach((opt) => {
                    const b = document.createElement("button");
                    b.className = "opt";
                    b.textContent = opt;
                    b.onclick = (e) => {
                        e.preventDefault();
                        modalQ.close();
                        if (opt === it.a) {
                            score += 5;
                            roomData.answered[idx] = true;
                            draw();
                            if (roomData.answered.every((v) => v))
                                openModalMsg(
                                    "M·ªü c·ªïng ‚¨ú",
                                    "B·∫°n ƒë√£ ho√†n t·∫•t 10/10 c√¢u."
                                );
                        } else {
                            if (window.hasShield) {
                                window.hasShield = false;
                                openModalMsg("Khi√™n üõ°Ô∏è", "B·∫°n tho√°t -1 m·∫°ng!");
                            } else loseLife("Sai c√¢u h·ªèi.");
                        }
                    };
                    optsBox.appendChild(b);
                });
                modalQ.showModal();
            }

            /* Movement */
            const dirs = {
                w: [0, -1],
                a: [-1, 0],
                s: [0, 1],
                d: [1, 0],
                ArrowUp: [0, -1],
                ArrowLeft: [-1, 0],
                ArrowDown: [0, 1],
                ArrowRight: [1, 0],
            };
            window.addEventListener("keydown", (e) => {
                const d = dirs[e.key];
                if (!d) return;
                e.preventDefault();
                const nx = player.x + d[0] * SPEED,
                    ny = player.y + d[1] * SPEED;
                if (
                    nx >= 0 &&
                    nx < N &&
                    ny >= 0 &&
                    ny < N &&
                    maze[ny][nx] === 0
                ) {
                    player.x = nx;
                    player.y = ny;
                    draw();
                    stepOn(nx, ny);
                }
            });

            /* Start with comic */
            showOverlay("intro");
        </script>
    </body>
</html>
